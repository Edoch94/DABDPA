<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Distributed architectures for big data processing and analytics - 19&nbsp; Spark MLlib</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./18b_classification.html" rel="next">
<link href="./16_sparksql_dataframes.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Distributed architectures for big data processing and analytics</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Index</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_01_intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Big data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_architectures.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Big data architectures</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03b_HDFS_clc.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">HDFS and Hadoop: command line commands</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_intro_hadoop.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Hadoop and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_hadoop_implementation.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">How to write MapReduce programs in Hadoop</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_mapreduce_patterns_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">MapReduce patterns - 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_mapreduce_advanced_topics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">MapReduce and Hadoop Advanced Topics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_mapreduce_patterns_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">MapReduce patterns - 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_sql_operators_mapreduce.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Relational Algebra Operations and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b_spark_submit_execute.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">How to submit/execute a Spark application</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_intro_spark.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_rdd_based_programming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">RDD based programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_rdd_keyvalue_pairs.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">RDDs and key-value pairs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13_rdd_numbers.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">RDD of numbers</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14_cache_accumulators_broadcast.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Cache, Accumulators, Broadcast Variables</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15b_pagerank.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introduction to PageRank</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16_sparksql_dataframes.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Spark SQL and DataFrames</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18a_spark_mllib.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18b_classification.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18c_clustering.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Clustering algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18d_regression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Regression algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18e_mining.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Itemset and Association rule mining</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19_graph_analytics_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Graph analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_graph_analytics_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Graph Analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21_streaming_analytics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22_structured_streaming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23_streaming_frameworks.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#data-types" id="toc-data-types" class="nav-link active" data-scroll-target="#data-types">Data types</a></li>
  <li><a href="#main-concepts" id="toc-main-concepts" class="nav-link" data-scroll-target="#main-concepts">Main concepts</a></li>
  <li><a href="#data-preprocessing" id="toc-data-preprocessing" class="nav-link" data-scroll-target="#data-preprocessing">Data preprocessing</a></li>
  <li><a href="#feature-transformations" id="toc-feature-transformations" class="nav-link" data-scroll-target="#feature-transformations">Feature transformations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Spark MLlib is the Spark component providing the machine learning/data mining algorithms</p>
<ul>
<li>Pre-processing techniques</li>
<li>Classification (supervised learning)</li>
<li>Clustering (unsupervised learning)</li>
<li>Itemset mining</li>
</ul>
<p>MLlib APIs are divided into two packages:</p>
<ul>
<li><code>pyspark.mllib</code>: It contains the original APIs built on top of RDDs. This version of the APIs is in maintenance mode and will be probably deprecated in the next releases of Spark.</li>
<li><code>pyspark.ml</code>: It provides higher-level API built on top of DataFrames (i.e, Dataset&lt;Row&gt;) for constructing ML pipelines. It is recommended because the DataFrame-based API is more versatile and flexible, also providing the pipeline concept. This is the one explained in this course.</li>
</ul>
<section id="data-types" class="level3">
<h3 class="anchored" data-anchor-id="data-types">Data types</h3>
<p>Spark MLlib is based on a set of basic local and distributed data types:</p>
<ul>
<li>Local vector</li>
<li>Local matrix</li>
<li>Distributed matrix</li>
<li>…</li>
</ul>
<p>DataFrames for ML-based applications contain objects based on these basic data types.</p>
<section id="local-vectors" class="level4">
<h4 class="anchored" data-anchor-id="local-vectors">Local vectors</h4>
<p>Local <code>pyspark.ml.linalg.Vector</code> objects in MLlib are used to store vectors (in dense and sparse representations) of double values. The MLlib algorithms work on vectors of doubles, used to represent the input records/data (one vector for each input record). Non double attributes/values must be mapped to double values before applying MLlib algorithms.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider the vector of doubles <code>[1.0, 0.0, 3.0]</code>. It can be represented</p>
<ul>
<li>In dense format as <code>[1.0, 0.0, 3.0]</code></li>
<li>In sparse format as <code>(3, [0, 2], [1.0, 3.0])</code>, where
<ul>
<li>3 is the size of the vector</li>
<li>The array <code>[0, 2]</code> contains the indexes of the non-zero cells</li>
<li>The array <code>[1.0, 3.0]</code> contains the values of the non-zero cells</li>
</ul></li>
</ul>
<p>The following code shows how dense and sparse vectors can be created in Spark</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> pyspark.ml.linalg <span class="im">import</span> Vectors</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">## Create a dense vector [1.0, 0.0, 3.0]</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>dv <span class="op">=</span> Vectors.dense([<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">3.0</span>])</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">## Create a sparse vector [1.0, 0.0, 3.0] by specifying</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">## its indices and values corresponding to non-zero entries</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">## by means of a dictionary</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>sv <span class="op">=</span> Vectors.sparse(<span class="dv">3</span>, { <span class="dv">0</span>:<span class="fl">1.0</span>, <span class="dv">2</span>:<span class="fl">3.0</span> })</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the sparse vector</p>
<table class="table">
<tbody>
<tr class="odd">
<td><code>3</code></td>
<td>Size of the vector</td>
</tr>
<tr class="even">
<td><code>2:3.0</code></td>
<td>Index and value of a non-empty cell</td>
</tr>
<tr class="odd">
<td><code>{ 0:1.0, 2:3.0 }</code></td>
<td>Dictionary of <span class="math inline">\(index:value\)</span> pairs</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
<section id="local-matrices" class="level4">
<h4 class="anchored" data-anchor-id="local-matrices">Local matrices</h4>
<p>Local <code>pyspark.ml.linalg.Matrix</code> objects in MLlib are used to store matrices (in dense and sparse representations) of double values. The column-major order is used to store the content of the matrix in a linear way.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Local matrices</figcaption><p></p>
<p><img src="images/18a_spark_mllib/matrix_example.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The following code shows how dense and sparse matrices can be created in Spark.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> pyspark.ml.linalg <span class="im">import</span> Matrices</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">## Create a dense matrix with two rows and three columns</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">## 3.0 0.0 0.0</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">## 1.0 1.5 2.0</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>dm <span class="op">=</span>Matrices.dense(<span class="dv">2</span>,<span class="dv">3</span>,[<span class="fl">3.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">1.5</span>, <span class="fl">0.0</span>, <span class="fl">2.0</span>])</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">## Create a sparse version of the same matrix</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>sm <span class="op">=</span> Matrices.sparse(<span class="dv">2</span>,<span class="dv">3</span>, [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>] , [<span class="dv">3</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the dense matrix vector</p>
<table class="table">
<tbody>
<tr class="odd">
<td><code>2</code></td>
<td>Number of rows</td>
</tr>
<tr class="even">
<td><code>3</code></td>
<td>Number of columns</td>
</tr>
<tr class="odd">
<td><code>[3.0, 1.0, 0.0, 1.5, 0.0, 2.0]</code></td>
<td>Values in column/major order</td>
</tr>
</tbody>
</table>
<p>In the sparse matrix vector</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<tbody>
<tr class="odd">
<td><code>2</code></td>
<td>Number of rows</td>
</tr>
<tr class="even">
<td><code>3</code></td>
<td>Number of columns</td>
</tr>
<tr class="odd">
<td><code>[0, 2, 3, 4]</code></td>
<td>One element per column that encodes the offset in the array of non-zero values where the values of the given column start. The last element is the number of non-zero values.</td>
</tr>
<tr class="even">
<td><code>[0, 1, 1, 1]</code></td>
<td>Row index of each non-zero value</td>
</tr>
<tr class="odd">
<td><code>[3, 1, 1.5, 2]</code></td>
<td>Array of non-zero values of the represented matrix</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
</section>
<section id="main-concepts" class="level3">
<h3 class="anchored" data-anchor-id="main-concepts">Main concepts</h3>
<p>Spark MLlib uses DataFrames as input data: the input of the MLlib algorithms are structured data (i.e., tables), and all input data must be represented by means of tables before applying the MLlib algorithms; also document collections must be transformed in a tabular format before applying the MLlib algorithms.</p>
<p>The DataFrames used and created by the MLlib algorithms are characterized by several columns, and each column is associated with a different role/meaning</p>
<ul>
<li><strong>label</strong>: the target of a classification/regression analysis;</li>
<li><strong>features</strong>: the vector containing the values of the attributes/features of the input record/data points;</li>
<li><strong>text</strong>: the original text of a document before being transformed in a tabular format;</li>
<li><strong>prediction</strong>: the predicted value of a classification/regression analysis.</li>
</ul>
<section id="transformer" class="level4">
<h4 class="anchored" data-anchor-id="transformer">Transformer</h4>
<p>A Transformer is an ML algorithm/procedure that transforms one DataFrame into another DataFrame by means of the method <code>transform(inputDataFrame)</code>.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example 1
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A feature transformer might take a DataFrame, read a column (e.g., text), map it into a new column (e.g., feature vectors), and output a new DataFrame with the mapped column appended.</p>
</div>
</div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example 2
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A classification model is a Transformer that can be applied on a DataFrame with features and transforms it into a DataFrame with also the prediction column.</p>
</div>
</div>
</div>
</section>
<section id="estimator" class="level4">
<h4 class="anchored" data-anchor-id="estimator">Estimator</h4>
<p>An Estimator is an ML algorithm/procedure that is fit on an input (training) DataFrame to produce a Transformer: each Estimator implements a <code>fit()</code> method, which accepts a DataFrame and produces a Model of type <code>Transformer</code>.</p>
<p>An Estimator abstracts the concept of a learning algorithm or any algorithm that fits/trains on an input dataset and returns a model</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The Logistic Regression classification algorithm is an Estimator: calling <code>fit(input training DataFrame)</code> on it a Logistic Regression Model is built, which is a Model/a Transformer.</p>
</div>
</div>
</div>
</section>
<section id="pipeline" class="level4">
<h4 class="anchored" data-anchor-id="pipeline">Pipeline</h4>
<p>A Pipeline chains multiple Transformers and Estimators together to specify a Machine learning/Data Mining workflow. In a pipeline, the output of a transformer/estimator is the input of the next one.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A simple text document processing workflow aiming at building a classification model includes several steps</p>
<ol type="1">
<li>Split each document into a set of words;</li>
<li>Convert each set of words into a numerical feature vector;</li>
<li>Learn a prediction model using the feature vectors and the associated class labels.</li>
</ol>
</div>
</div>
</div>
</section>
<section id="parameters" class="level4">
<h4 class="anchored" data-anchor-id="parameters">Parameters</h4>
<p>Transformers and Estimators share common APIs for specifying the values of their parameters.</p>
<p>In the new APIs of Spark MLlib the use of the pipeline approach is preferred/recommended. This approach is based on the following steps</p>
<ol type="1">
<li>The set of Transformers and Estimators that are needed are instantiated;</li>
<li>A pipeline object is created and the sequence of transformers and estimators associated with the pipeline are specified;</li>
<li>The pipeline is executed and a model is trained;</li>
<li>(optional) The model is applied on new data.</li>
</ol>
</section>
</section>
<section id="data-preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="data-preprocessing">Data preprocessing</h3>
<p>Input data must be preprocessed before applying machine learning and data mining algorithms</p>
<ul>
<li>To organize data in a format consistent with the one expected by the applied algorithms;</li>
<li>To define good (predictive) features;</li>
<li>To remove bias (e.g., normalization);</li>
<li>To remove noise and missing values.</li>
</ul>
<section id="extracting-transformings-and-selecting-features" class="level4">
<h4 class="anchored" data-anchor-id="extracting-transformings-and-selecting-features">Extracting, transformings, and selecting features</h4>
<p>MLlib provides a set of transformers than can be used to extract, transform and select features from DataFrames</p>
<ul>
<li>Feature Extractors (e.g., TF-IDF, Word2Vec)</li>
<li>Feature Transformers (e.g., Tokenizer, StopWordsRemover, StringIndexer, IndexToString, OneHotEncoderEstimator, Normalizer)</li>
<li>Feature Selectors (e.g., VectorSlicer)</li>
</ul>
<p>See the up-to-date list <a href="https://spark.apache.org/docs/latest/ml-features.html">here</a>.</p>
</section>
</section>
<section id="feature-transformations" class="level3">
<h3 class="anchored" data-anchor-id="feature-transformations">Feature transformations</h3>
<p>Several algorithms are provided by MLlib to transform features. They are used to create new columns/features by combining or transforming other features It is possible to perform feature transformations and feature creations by using the standard methods for DataFrames and RDDs.</p>
<section id="vectorassembler" class="level4">
<h4 class="anchored" data-anchor-id="vectorassembler"><code>VectorAssembler</code></h4>
<p><code>VectorAssembler</code> (<code>pyspark.ml.feature.VectorAssembler</code>) is a transformer that combines a given list of columns into a single vector column. It is useful for combining features into a single feature vector before applying ML algorithms.</p>
<p>Given <code>VectorAssembler(inputCols, outputCol)</code></p>
<ul>
<li><code>inputCols</code>: the list of original columns to include in the new column of type <code>Vector</code>. The following input column types are accepted
<ul>
<li>all numeric types, boolean type, and vector type</li>
<li>Boolean values are mapped to 1 (True) and 0 (False)</li>
</ul></li>
<li><code>outputCol</code>: the name of the new output column</li>
</ul>
<p>When the transform method of VectorAssembler is invoked on a DataFrame the returned DataFrame has a new column (outputCol): for each record, the value of the new column is the concatenation of the values of the input columns. It has also all the columns of the input DataFrame.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider an input DataFrame with three columns: create a new DataFrame with a new column containing the concatenation of “colB” and “colC” in a new vector column. Set the name of the new column to “features”.</p>
<p><strong>Original DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>colA</th>
<th>colB</th>
<th>colC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(4.5\)</span></td>
<td>True</td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(0.6\)</span></td>
<td>True</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(1.5\)</span></td>
<td>False</td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(12.1\)</span></td>
<td>True</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
<td>True</td>
</tr>
</tbody>
</table>
<p><strong>Transformed DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>colA</th>
<th>colB</th>
<th>colC</th>
<th>features</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(4.5\)</span></td>
<td>True</td>
<td><span class="math inline">\([4.5,1.0]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(0.6\)</span></td>
<td>True</td>
<td><span class="math inline">\([0.6,1.0]\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(1.5\)</span></td>
<td>False</td>
<td><span class="math inline">\([1.5,0.0]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(12.1\)</span></td>
<td>True</td>
<td><span class="math inline">\([12.1,1.0]\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
<td>True</td>
<td><span class="math inline">\([0.0,1.0]\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p>Notice that columns of DataFrames can also be vectors.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">## input and output folders</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>inputPath <span class="op">=</span> <span class="st">"data/exampleDataAssembler.csv“</span></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="er">## Create a DataFrame from the input data</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="er">inputDF = spark.read.load(</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="er">    inputPath,</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="er">    format="csv",</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="er">    header=True,</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="er">    inferSchema=True</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="er">)</span></span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="er">## Create a VectorAssembler that combines columns colB and colC</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="er">## The new vetor column is called features</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="er">myVectorAssembler = VectorAssembler(</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="er">    inputCols = ['colB', 'colC'],</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="er">    outputCol = 'features'</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="er">)</span></span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="er">## Apply myVectorAssembler on the input DataFrame</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="er">transformedDF = myVectorAssembler.transform(inputDF)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
<section id="data-normalization" class="level4">
<h4 class="anchored" data-anchor-id="data-normalization">Data Normalization</h4>
<p>MLlib provides a set of normalization algorithms (called scalers)</p>
<ul>
<li>StandardScaler</li>
<li>MinMaxScaler</li>
<li>Normalizer</li>
<li>MaxAbsScaler</li>
</ul>
<section id="standardscaler" class="level5">
<h5 class="anchored" data-anchor-id="standardscaler"><code>StandardScaler</code></h5>
<p><code>StandardScaler</code> (<code>pyspark.ml.feature.StandardScaler</code>) is an Estimator that returns a Transformer (<code>pyspark.ml.feature.StandardScalerModel</code>). <code>StandardScalerModel</code> transforms a vector column of an input DataFrame normalizing each feature of the input vector column to have unit standard deviation and/or zero mean.</p>
<p>Given <code>StandardScaler(inputCol, outputCol)</code></p>
<ul>
<li><code>inputCol</code>: the name of the input vector column (of doubles) to normalize</li>
<li><code>outputCol</code>: the name of the new output normalized vector column</li>
</ul>
<p>Invoke the fit method of <code>StandardScaler</code> on the input DataFrame to infer a <code>StandardScalerModel</code>. The returned model is a Transformer.</p>
<p>Invoke the transform method of <code>StandardScalerModel</code> on the input DataFrame to create a new DataFrame that has a new column (<code>outputCol</code>): for each record, the value of the new column is the normalized version of the input vector column. It has also all the columns of the input DataFrame.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider an input DataFrame with four columns: create a new DataFrame with a new column containing the normalized version of the vector column features. Set the name of the new column to “scaledFeatures”.</p>
<p><strong>Original DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>colA</th>
<th>colB</th>
<th>colC</th>
<th>features</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(4.5\)</span></td>
<td>True</td>
<td><span class="math inline">\([4.5,1.0]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(0.6\)</span></td>
<td>True</td>
<td><span class="math inline">\([0.6,1.0]\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(1.5\)</span></td>
<td>False</td>
<td><span class="math inline">\([1.5,0.0]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(12.1\)</span></td>
<td>True</td>
<td><span class="math inline">\([12.1,1.0]\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
<td>True</td>
<td><span class="math inline">\([0.0,1.0]\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Transformed DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>colA</th>
<th>colB</th>
<th>colC</th>
<th>features</th>
<th>scaledFeatures</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(4.5\)</span></td>
<td>True</td>
<td><span class="math inline">\([4.5,1.0]\)</span></td>
<td><span class="math inline">\([0.903,2.236]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(0.6\)</span></td>
<td>True</td>
<td><span class="math inline">\([0.6,1.0]\)</span></td>
<td><span class="math inline">\([0.120,2.236]\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(1.5\)</span></td>
<td>False</td>
<td><span class="math inline">\([1.5,0.0]\)</span></td>
<td><span class="math inline">\([0.301,0.0]\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(12.1\)</span></td>
<td>True</td>
<td><span class="math inline">\([12.1,1.0]\)</span></td>
<td><span class="math inline">\([2.428,2.236]\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
<td>True</td>
<td><span class="math inline">\([0.0,1.0]\)</span></td>
<td><span class="math inline">\([0.0,2.236]\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> StandardScaler</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">## input and output folders</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>inputPath <span class="op">=</span> <span class="st">"data/exampleDataAssembler.csv“</span></span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="er">## Create a DataFrame from the input data</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="er">inputDF = spark.read.load(</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="er">    inputPath,</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="er">    format="csv",</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="er">    header=True,</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="er">    inferSchema=True</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="er">)</span></span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="er">## Create a VectorAssembler that combines columns colB and colC</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="er">## The new vetor column is called features</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="er">myVectorAssembler = VectorAssembler(</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="er">    inputCols = ['colB', 'colC'],</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="er">    outputCol = 'features'</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="er">)</span></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a><span class="er">## Apply myVectorAssembler on the input DataFrame</span></span>
<span id="cb4-23"><a href="#cb4-23"></a><span class="er">transformedDF = myVectorAssembler.transform(inputDF)</span></span>
<span id="cb4-24"><a href="#cb4-24"></a></span>
<span id="cb4-25"><a href="#cb4-25"></a><span class="er">## Create a Standard Scaler to scale the content of features</span></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="er">myScaler = StandardScaler(</span></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="er">    inputCol="features",</span></span>
<span id="cb4-28"><a href="#cb4-28"></a><span class="er">    outputCol="scaledFeatures"</span></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="er">)</span></span>
<span id="cb4-30"><a href="#cb4-30"></a></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="er">## Compute summary statistics by fitting the StandardScaler</span></span>
<span id="cb4-32"><a href="#cb4-32"></a><span class="er">## Before normalizing the content of the data we need to compute mean and</span></span>
<span id="cb4-33"><a href="#cb4-33"></a><span class="er">## standard deviation of the analyzed data</span></span>
<span id="cb4-34"><a href="#cb4-34"></a><span class="er">scalerModel = myScaler.fit(transformedDF)</span></span>
<span id="cb4-35"><a href="#cb4-35"></a></span>
<span id="cb4-36"><a href="#cb4-36"></a><span class="er">## Apply myScaler on the input column features</span></span>
<span id="cb4-37"><a href="#cb4-37"></a><span class="er">scaledDF = scalerModel.transform(transformedDF)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="categorical-columns" class="level4">
<h4 class="anchored" data-anchor-id="categorical-columns">Categorical columns</h4>
<p>Frequently the input data are characterized by categorical attributes (i.e., string columns), and the class label of the classification problem is a categorical attribute. The Spark MLlib classification and regression algorithms work only with numerical values, so categorical columns must be mapped to double values.</p>
<section id="stringindexer" class="level5">
<h5 class="anchored" data-anchor-id="stringindexer"><code>StringIndexer</code></h5>
<p>A <code>StringIndexer</code> (<code>pyspark.ml.feature.StringIndexer</code>) is an Estimator that returns a Transformer of type <code>pyspark.ml.feature.StringIndexerModel</code>. <code>StringIndexerModel</code> encodes a string column of “labels” to a column of “label indices”: each distinct value of the input string column is mapped to an integer value in <span class="math inline">\([0, \textbf{number of distinct values})\)</span>.</p>
<p><code>StringIndexer(inputCol, outputCol)</code></p>
<ul>
<li><code>inputCol</code>: the name of the input string column to map to a set of integers</li>
<li><code>outputCol</code>: the name of the new output column</li>
</ul>
<p>Invoke the fit method of <code>StringIndexer</code> on the input DataFrame to infer a <code>StringIndexerModel</code>. The returned model is a Transformer.</p>
<p>Invoke the transform method of <code>StringIndexerModel</code> on the input DataFrame to create a new DataFrame that has a new column (<code>outputCol</code>): for each record, the value of the new column is the integer (casted to a double) associated with the value of the input string column. It has also all the columns of the input DataFrame.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider an input DataFrame with two columns: create a new DataFrame with a new column containing the integer version of the string column category. Set the name of the new column to “categoryIndex”.</p>
<p><strong>Original DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>id</th>
<th>category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td>a</td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td>b</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td>c</td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td>c</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td>a</td>
</tr>
</tbody>
</table>
<p><strong>Transformed DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>id</th>
<th>category</th>
<th>categoryIndex</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td>a</td>
<td><span class="math inline">\(0.0\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td>b</td>
<td><span class="math inline">\(2.0\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td>c</td>
<td><span class="math inline">\(1.0\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td>c</td>
<td><span class="math inline">\(1.0\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td>a</td>
<td><span class="math inline">\(0.0\)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> StringIndexer</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">## input DataFrame</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>df <span class="op">=</span> spark.createDataFrame(</span>
<span id="cb5-6"><a href="#cb5-6"></a>    [(<span class="dv">1</span>,<span class="st">"a"</span>),(<span class="dv">2</span>,<span class="st">"b"</span>),(<span class="dv">3</span>,<span class="st">"c"</span>),(<span class="dv">4</span>,<span class="st">"c"</span>),(<span class="dv">5</span>,<span class="st">"a"</span>)],</span>
<span id="cb5-7"><a href="#cb5-7"></a>    [<span class="st">"id"</span>,<span class="st">"category"</span>]</span>
<span id="cb5-8"><a href="#cb5-8"></a>)</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">## Create a StringIndexer to map the content of category</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">##  to a set of "integers"</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>indexer <span class="op">=</span> StringIndexer(</span>
<span id="cb5-13"><a href="#cb5-13"></a>    inputCol<span class="op">=</span><span class="st">"category"</span>, </span>
<span id="cb5-14"><a href="#cb5-14"></a>    outputCol<span class="op">=</span><span class="st">"categoryIndex"</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>)</span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">## Analyze the input data to define the mapping string -&gt; integer</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>indexerModel <span class="op">=</span> indexer.fit(df)</span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="co">## Apply indexerModel on the input column category</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>indexedDF <span class="op">=</span> indexerModel.transform(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
<section id="indextostring" class="level5">
<h5 class="anchored" data-anchor-id="indextostring"><code>IndexToString</code></h5>
<p><code>IndexToString</code> (<code>pyspark.ml.feature.IndexToString</code>), which is symmetrical to <code>StringIndexer</code>, is a Transformer that maps a column of “label indices” back to a column containing the original “labels” as strings. Classification models return the integer version of the predicted label values. To obtain human readable results, remap those values to the original ones.</p>
<p>Given <code>IndexToString(inputCol, outputCol, labels)</code></p>
<ul>
<li>inputCol: the name of the input numerical column to map to the original a set of string “labels”;</li>
<li>outputCol: the name of the new output column;</li>
<li>labels: the list of original “labels”/strings; the mapping with integer values is given by the positions of the strings inside labels.</li>
</ul>
<p>Invoke the transform method of <code>IndexToString</code> on the input DataFrame to create a new DataFrame that has a new column (<code>outputCol</code>): for each record, the value of the new column is the original string associated with the value of the input numerical column. It has also all the columns of the input DataFrame.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider an input DataFrame with two columns: create a new DataFrame with a new column containing the integer version of the string column category and then map it back to the string version in a new column.</p>
<p><strong>Original DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>id</th>
<th>category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td>a</td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td>b</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td>c</td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td>c</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td>a</td>
</tr>
</tbody>
</table>
<p><strong>Transformed DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>id</th>
<th>category</th>
<th>categoryIndex</th>
<th>originalCategory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td>a</td>
<td><span class="math inline">\(0.0\)</span></td>
<td>a</td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td>b</td>
<td><span class="math inline">\(2.0\)</span></td>
<td>b</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td>c</td>
<td><span class="math inline">\(1.0\)</span></td>
<td>c</td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td>c</td>
<td><span class="math inline">\(1.0\)</span></td>
<td>c</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td>a</td>
<td><span class="math inline">\(0.0\)</span></td>
<td>a</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> StringIndexer</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> IndexToString</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">## input DataFrame</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>df <span class="op">=</span> spark.createDataFrame(</span>
<span id="cb6-7"><a href="#cb6-7"></a>    [(<span class="dv">1</span>,<span class="st">"a"</span>),(<span class="dv">2</span>,<span class="st">"b"</span>),(<span class="dv">3</span>,<span class="st">"c"</span>),(<span class="dv">4</span>,<span class="st">"c"</span>),(<span class="dv">5</span>,<span class="st">"a"</span>)],</span>
<span id="cb6-8"><a href="#cb6-8"></a>    [<span class="st">"id"</span>,<span class="st">"category"</span>]</span>
<span id="cb6-9"><a href="#cb6-9"></a>)</span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">## Create a StringIndexer to map the content of category </span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">## to a set of integers</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>indexer <span class="op">=</span> StringIndexer(</span>
<span id="cb6-14"><a href="#cb6-14"></a>    inputCol<span class="op">=</span><span class="st">"category"</span>, </span>
<span id="cb6-15"><a href="#cb6-15"></a>    outputCol<span class="op">=</span><span class="st">"categoryIndex"</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>)</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">## Analyze the input data to define the mapping </span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co">## string -&gt; integer</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>indexerModel <span class="op">=</span> indexer.fit(df)</span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="co">## Apply indexerModel on the input column category</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>indexedDF <span class="op">=</span> indexerModel.transform(df)</span>
<span id="cb6-24"><a href="#cb6-24"></a></span>
<span id="cb6-25"><a href="#cb6-25"></a><span class="co">## Create an IndexToString to map the content of numerical </span></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="co">## attribute categoryIndex to the original string value</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>converter <span class="op">=</span> IndexToString(</span>
<span id="cb6-28"><a href="#cb6-28"></a>    inputCol<span class="op">=</span><span class="st">"categoryIndex"</span>, </span>
<span id="cb6-29"><a href="#cb6-29"></a>    outputCol<span class="op">=</span><span class="st">"originalCategory"</span>,</span>
<span id="cb6-30"><a href="#cb6-30"></a>    labels<span class="op">=</span>indexerModel.labels</span>
<span id="cb6-31"><a href="#cb6-31"></a>)</span>
<span id="cb6-32"><a href="#cb6-32"></a></span>
<span id="cb6-33"><a href="#cb6-33"></a><span class="co">## Apply converter on the input column categoryIndex</span></span>
<span id="cb6-34"><a href="#cb6-34"></a>reconvertedDF <span class="op">=</span> converter.transform(indexedDF)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
<section id="sqltransformer" class="level5">
<h5 class="anchored" data-anchor-id="sqltransformer"><code>SQLTransformer</code></h5>
<p><code>SQLTransformer</code> (<code>pyspark.ml.feature.SQLTransformer</code>) is a transformer that implements the transformations which are defined by SQL queries. Currently, the syntax of the supported (simplified) SQL queries is</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">SELECT</span> <span class="kw">attributes</span>, <span class="kw">function</span>(<span class="kw">attributes</span>) <span class="kw">FROM</span> __THIS__</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Where <code>__THIS__</code> represents the DataFrame on which the <code>SQLTransformer</code> is invoked.</p>
<p><code>SQLTransformer</code> executes an SQL query on the input DataFrame and returns a new DataFrame associated with the result of the query.</p>
<p>Given <code>SQLTransformer(statement)</code></p>
<ul>
<li><code>statement</code>: the SQL query to execute.</li>
</ul>
<p>When the transform method of <code>SQLTransformer</code> is invoked on a DataFrame the returned DataFrame is the result of the executed statement query.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider an input DataFrame with two columns: “text” and “id”: create a new DataFrame with a new column, called “numWords”, containing the number of words occurring in column “text”.</p>
<p><strong>Original DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>id</th>
<th>text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td>This is Spark</td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td>Spark</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td>Another sample sentence of words</td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td>Paolo Rossi</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td>Giovanni</td>
</tr>
</tbody>
</table>
<p><strong>Transformed DataFrame</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>id</th>
<th>text</th>
<th>numWords</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td>This is Spark</td>
<td><span class="math inline">\(3\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td>Spark</td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td>Another sample sentence of words</td>
<td><span class="math inline">\(5\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td>Paolo Rossi</td>
<td><span class="math inline">\(2\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td>Giovanni</td>
<td><span class="math inline">\(1\)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">from</span> pyspark.sql.types <span class="im">import</span> <span class="op">*</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> SQLTransformer</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">#Local Input data</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>inputList <span class="op">=</span> [</span>
<span id="cb8-6"><a href="#cb8-6"></a>    (<span class="dv">1</span>,<span class="st">"ThisisSpark"</span>),</span>
<span id="cb8-7"><a href="#cb8-7"></a>    (<span class="dv">2</span>,<span class="st">"Spark"</span>),</span>
<span id="cb8-8"><a href="#cb8-8"></a>    (<span class="dv">3</span>,<span class="st">"Anothersamplesentenceofwords"</span>),</span>
<span id="cb8-9"><a href="#cb8-9"></a>    (<span class="dv">4</span>,<span class="st">"PaoloRossi"</span>),</span>
<span id="cb8-10"><a href="#cb8-10"></a>    (<span class="dv">5</span>,<span class="st">"Giovanni"</span>)</span>
<span id="cb8-11"><a href="#cb8-11"></a>]</span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co">## Create the initial DataFrame</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>dfInput <span class="op">=</span> spark.createDataFrame(</span>
<span id="cb8-15"><a href="#cb8-15"></a>    inputList, </span>
<span id="cb8-16"><a href="#cb8-16"></a>    [<span class="st">"id"</span>,<span class="st">"text"</span>]</span>
<span id="cb8-17"><a href="#cb8-17"></a>)</span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co">## Define a UDF function that that counts the number of words </span></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="co">## in an input string</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>spark.udf.register(</span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="st">"countWords"</span>, </span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="kw">lambda</span> text: <span class="bu">len</span>(text.split(<span class="st">" "</span>)), </span>
<span id="cb8-24"><a href="#cb8-24"></a>    IntegerType()</span>
<span id="cb8-25"><a href="#cb8-25"></a>)</span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a><span class="co">## Define an SQLTranformer to create the columns we are </span></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="co">## interested in</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>sqlTrans <span class="op">=</span> SQLTransformer(</span>
<span id="cb8-30"><a href="#cb8-30"></a>    statement<span class="op">=</span><span class="st">"""</span></span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="st">    SELECT *, countWords(text) AS numLines </span></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="st">    FROM __THIS__</span></span>
<span id="cb8-33"><a href="#cb8-33"></a><span class="st">    """</span></span>
<span id="cb8-34"><a href="#cb8-34"></a>)</span>
<span id="cb8-35"><a href="#cb8-35"></a></span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="co">## Create the new DataFrame by invoking the transform method of </span></span>
<span id="cb8-37"><a href="#cb8-37"></a><span class="co">## the defined SQLTranformer</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>newDF <span class="op">=</span> sqlTrans.transform(dfInput)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./16_sparksql_dataframes.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Spark SQL and DataFrames</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./18b_classification.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>