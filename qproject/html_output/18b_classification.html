<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Distributed architectures for big data processing and analytics - 20&nbsp; Classification algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./18c_clustering.html" rel="next">
<link href="./18a_spark_mllib.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Distributed architectures for big data processing and analytics</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Index</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_01_intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Big data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_architectures.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Big data architectures</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03b_HDFS_clc.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">HDFS and Hadoop: command line commands</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_intro_hadoop.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Hadoop and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_hadoop_implementation.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">How to write MapReduce programs in Hadoop</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_mapreduce_patterns_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">MapReduce patterns - 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_mapreduce_advanced_topics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">MapReduce and Hadoop Advanced Topics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_mapreduce_patterns_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">MapReduce patterns - 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_sql_operators_mapreduce.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Relational Algebra Operations and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b_spark_submit_execute.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">How to submit/execute a Spark application</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_intro_spark.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_rdd_based_programming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">RDD based programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_rdd_keyvalue_pairs.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">RDDs and key-value pairs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13_rdd_numbers.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">RDD of numbers</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14_cache_accumulators_broadcast.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Cache, Accumulators, Broadcast Variables</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15b_pagerank.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introduction to PageRank</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16_sparksql_dataframes.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Spark SQL and DataFrames</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18a_spark_mllib.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18b_classification.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18c_clustering.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Clustering algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18d_regression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Regression algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18e_mining.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Itemset and Association rule mining</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19_graph_analytics_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Graph analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_graph_analytics_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Graph Analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21_streaming_analytics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22_structured_streaming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23_streaming_frameworks.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#structured-data-classification" id="toc-structured-data-classification" class="nav-link active" data-scroll-target="#structured-data-classification">Structured data classification</a></li>
  <li><a href="#categorical-class-labels" id="toc-categorical-class-labels" class="nav-link" data-scroll-target="#categorical-class-labels">Categorical class labels</a></li>
  <li><a href="#textual-data-management-and-classification" id="toc-textual-data-management-and-classification" class="nav-link" data-scroll-target="#textual-data-management-and-classification">Textual data management and classification</a></li>
  <li><a href="#performance-evaluation" id="toc-performance-evaluation" class="nav-link" data-scroll-target="#performance-evaluation">Performance evaluation</a></li>
  <li><a href="#hyperparameter-tuning" id="toc-hyperparameter-tuning" class="nav-link" data-scroll-target="#hyperparameter-tuning">Hyperparameter tuning</a></li>
  <li><a href="#sparse-labeled-data" id="toc-sparse-labeled-data" class="nav-link" data-scroll-target="#sparse-labeled-data">Sparse labeled data</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Spark MLlib provides a (limited) set of classification algorithms</p>
<ul>
<li>Logistic regression
<ul>
<li>Binomial logistic regression</li>
<li>Multinomial logistic regression</li>
</ul></li>
<li>Decision tree classifier</li>
<li>Random forest classifier</li>
<li>Gradient-boosted tree classifier</li>
<li>Multilayer perceptron classifier</li>
<li>Linear Support Vector Machine</li>
</ul>
<p>All the available classification algorithms are based on two phases:</p>
<ol type="1">
<li>Model generation based on a set of training data</li>
<li>Prediction of the class label of new unlabeled data</li>
</ol>
<p>All the classification algorithms available in Spark work only on numerical attributes: categorical values must be mapped to integer values (one distinct value per class) before applying the MLlib classification algorithms.</p>
<p>All the Spark classification algorithms are trained on top of an input DataFrame containing (at least) two columns</p>
<ul>
<li>label: the class label, (i.e., the attribute to be predicted by the classification model); it is an integer value (casted to a double)</li>
<li>features: a vector of doubles containing the values of the predictive attributes of the input records/data points; the data type of this column is <code>pyspark.ml.linalg.Vector</code>, and both dense and sparse vectors can be used</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Consider the following classification problem: the goal is to predict if new customers are good customers or not based on their monthly income and number of children.</p>
<p>The predictive attributes are</p>
<ul>
<li>Monthly income</li>
<li>Number of children</li>
</ul>
<p>The class label (target attribute) is “Customer type”:</p>
<ul>
<li>“Good customer”, mapped to 1</li>
<li>“Bad customer”, mapped to 0</li>
</ul>
<p><strong>Example of input training data</strong></p>
<p>The training data is the set of customers for which the value of the class label is known: they are used by the classification algorithm to infer/train a classification model.</p>
<table class="table">
<thead>
<tr class="header">
<th>CustomerType</th>
<th>MonthlyIncome</th>
<th>NumChildren</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Good customer</td>
<td><span class="math inline">\(1400.0\)</span></td>
<td><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td>Bad customer</td>
<td><span class="math inline">\(11105.5\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="odd">
<td>Good customer</td>
<td><span class="math inline">\(2150.0\)</span></td>
<td><span class="math inline">\(2\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Example of input training DataFrame</strong></p>
<p>The input training DataFrame that must be provided as input to train an MLlib classification algorithm must have the following structure</p>
<table class="table">
<thead>
<tr class="header">
<th>label</th>
<th>features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\([1400.0,2.0]\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(0.0\)</span></td>
<td><span class="math inline">\([11105.5,0.0]\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\([2150.0,2.0]\)</span></td>
</tr>
</tbody>
</table>
<p>Notice that</p>
<ul>
<li>The categorical values of “CustomerType” (the class label column) must be mapped to integer data values (then casted to doubles).</li>
<li>The values of the predictive attributes are stored in vectors of doubles. One single vector for each input record.</li>
<li>In the generated DataFrame the names of the predictive attributes are not preserved.</li>
</ul>
</div>
</div>
</div>
<section id="structured-data-classification" class="level3">
<h3 class="anchored" data-anchor-id="structured-data-classification">Structured data classification</h3>
<section id="example-of-logistic-regression-and-structured-data" class="level4">
<h4 class="anchored" data-anchor-id="example-of-logistic-regression-and-structured-data">Example of logistic regression and structured data</h4>
<p>The following paragraphs show how to</p>
<ul>
<li>Create a classification model based on the logistic regression algorithm on structured data: the model is inferred by analyzing the training data, (i.e., the example records/data points for which the value of the class label is known).</li>
<li>Apply the model to new unlabeled data: the inferred model is applied to predict the value of the class label of new unlabeled records/data points.</li>
</ul>
<section id="training-data" class="level5">
<h5 class="anchored" data-anchor-id="training-data">Training data</h5>
<p>The input training data is stored in a text file that contains one record/data point per line. The records/data points are structured data with a fixed number of attributes (four)</p>
<ul>
<li>One attribute is the class label: it assumed that the first column of each record contains the class label;</li>
<li>The other three attributes are the predictive attributes that are used to predict the value of the class label;</li>
</ul>
<p>The values are already doubles (no need to convert them), and the input file has the header line.</p>
<p>Consider the following example input training data file</p>
<pre><code>label,attr1,attr2,attr3
1.0,0.0,1.1,0.1
0.0,2.0,1.0,-1.0
0.0,2.0,1.3,1.0
1.0,0.0,1.2,-0.5</code></pre>
<p>It contains four records/data points. This is a binary classification problem because the class label assumes only two values: 0 and 1.</p>
<p>The first operation consists in transforming the content of the input training file into a DataFrame containing two columns</p>
<ul>
<li>label: the double value that is used to specify the label of each training record;</li>
<li>features: it is a vector of doubles associated with the values of the predictive features.</li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>label</th>
<th>features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\([0.0,1.1,0.1]\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(0.0\)</span></td>
<td><span class="math inline">\([2.0,1.0,-1.0]\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(0.0\)</span></td>
<td><span class="math inline">\([2.0,1.3,1.0]\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\([0.0,1.2,-0.5]\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>Data type of “label” is double</li>
<li>Data type of “features” is <code>pyspark.ml.linalg.Vector</code></li>
</ul>
</section>
<section id="unlabeled-data" class="level5">
<h5 class="anchored" data-anchor-id="unlabeled-data">Unlabeled data</h5>
<p>The file containing the unlabeled data has the same format of the training data file, however the first column is empty because the class label is unknown. The goal is to predict the class label value of each unlabeled data by applying the classification model that has been trained on the training data: the predicted class label value of the unlabeled data is stored in a new column, called “prediction”, of the returned DataFrame.</p>
<p>Consider the following input unlabeled data file</p>
<pre><code>label,attr1,attr2,attr3
,-1.0,1.5,1.3
,3.0,2.0,-0.1
,0.0,2.2,-1.5</code></pre>
<p>It contains three unlabeled records/data points. Notice that the first column is empty (the content before the first comma is the empty string).</p>
<p>Also the unlabeled data must be stored into a DataFrame containing two columns: “label” and “features”. So, “label” column is required also for unlabeled data, but its value is set to null for all records.</p>
<table class="table">
<thead>
<tr class="header">
<th>label</th>
<th>features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>null</td>
<td><span class="math inline">\([-1.0,1.5,1.3]\)</span></td>
</tr>
<tr class="even">
<td>null</td>
<td><span class="math inline">\([3.0,2.0,-0.1]\)</span></td>
</tr>
<tr class="odd">
<td>null</td>
<td><span class="math inline">\([0.0,2.2,-1.5]\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="prediction-column" class="level5">
<h5 class="anchored" data-anchor-id="prediction-column">Prediction column</h5>
<p>After the application of the classification model on the unlabeled data, Spark returns a new DataFrame containing</p>
<ul>
<li>The same columns of the input DataFrame</li>
<li>A new column called prediction, that, for each input unlabeled record, contains the predicted class label value</li>
<li>Two columns, associated with the probabilities of the predictions (these columns are not considered in the example)</li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>label</th>
<th>features</th>
<th>prediction</th>
<th>rawPrediction</th>
<th>probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>null</td>
<td><span class="math inline">\([-1.0,1.5,1.3]\)</span></td>
<td><span class="math inline">\(1.0\)</span></td>
<td>…</td>
<td>…</td>
</tr>
<tr class="even">
<td>null</td>
<td><span class="math inline">\([3.0,2.0,-0.1]\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
<td>…</td>
<td>…</td>
</tr>
<tr class="odd">
<td>null</td>
<td><span class="math inline">\([0.0,2.2,-1.5]\)</span></td>
<td><span class="math inline">\(1.0\)</span></td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The “prediction” column contains the predicted class label values.</p>
</section>
<section id="example-code" class="level5">
<h5 class="anchored" data-anchor-id="example-code">Example code</h5>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> LogisticRegression</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">## input and output folders</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>trainingData <span class="op">=</span> <span class="st">"ex_data/trainingData.csv"</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>unlabeledData <span class="op">=</span> <span class="st">"ex_data/unlabeledData.csv"</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>outputPath <span class="op">=</span> <span class="st">"predictionsLR/"</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">## *************************</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">## Training step</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">## *************************</span></span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">## Create a DataFrame from trainingData.csv</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">## Training data in raw format</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>trainingData <span class="op">=</span> spark.read.load(</span>
<span id="cb3-17"><a href="#cb3-17"></a>    trainingData,</span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb3-19"><a href="#cb3-19"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb3-20"><a href="#cb3-20"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>)</span>
<span id="cb3-22"><a href="#cb3-22"></a></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="co">## Define an assembler to create a column (features) of type Vector</span></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="co">## containing the double values associated with columns attr1, attr2, attr3</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>assembler <span class="op">=</span> VectorAssembler(</span>
<span id="cb3-26"><a href="#cb3-26"></a>    inputCols<span class="op">=</span>[<span class="st">"attr1"</span>,<span class="st">"attr2"</span>,<span class="st">"attr3"</span>],</span>
<span id="cb3-27"><a href="#cb3-27"></a>    outputCol<span class="op">=</span><span class="st">"features"</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>)</span>
<span id="cb3-29"><a href="#cb3-29"></a></span>
<span id="cb3-30"><a href="#cb3-30"></a><span class="co">## Apply the assembler to create column features for the training data</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>trainingDataDF <span class="op">=</span> assembler.transform(trainingData)</span>
<span id="cb3-32"><a href="#cb3-32"></a></span>
<span id="cb3-33"><a href="#cb3-33"></a><span class="co">## Create a LogisticRegression object.</span></span>
<span id="cb3-34"><a href="#cb3-34"></a><span class="co">## LogisticRegression is an Estimator that is used to</span></span>
<span id="cb3-35"><a href="#cb3-35"></a><span class="co">## create a classification model based on logistic regression.</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>lr <span class="op">=</span> LogisticRegression()</span>
<span id="cb3-37"><a href="#cb3-37"></a></span>
<span id="cb3-38"><a href="#cb3-38"></a><span class="co">## It is possible to set the values of the parameters of the</span></span>
<span id="cb3-39"><a href="#cb3-39"></a><span class="co">## Logistic Regression algorithm using the setter methods.</span></span>
<span id="cb3-40"><a href="#cb3-40"></a><span class="co">## There is one set method for each parameter</span></span>
<span id="cb3-41"><a href="#cb3-41"></a><span class="co">## For example, the number of maximum iterations is set to 10</span></span>
<span id="cb3-42"><a href="#cb3-42"></a><span class="co">## and the regularization parameter is set to 0.01</span></span>
<span id="cb3-43"><a href="#cb3-43"></a>lr.setMaxIter(<span class="dv">10</span>)</span>
<span id="cb3-44"><a href="#cb3-44"></a>lr.setRegParam(<span class="fl">0.01</span>)</span>
<span id="cb3-45"><a href="#cb3-45"></a></span>
<span id="cb3-46"><a href="#cb3-46"></a><span class="co">## Train a logistic regression model on the training data</span></span>
<span id="cb3-47"><a href="#cb3-47"></a>classificationModel <span class="op">=</span> lr.fit(trainingDataDF)</span>
<span id="cb3-48"><a href="#cb3-48"></a></span>
<span id="cb3-49"><a href="#cb3-49"></a><span class="co">## *************************</span></span>
<span id="cb3-50"><a href="#cb3-50"></a><span class="co">## Prediction step</span></span>
<span id="cb3-51"><a href="#cb3-51"></a><span class="co">## *************************</span></span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a><span class="co">## Create a DataFrame from unlabeledData.csv</span></span>
<span id="cb3-54"><a href="#cb3-54"></a><span class="co">## Unlabeled data in raw format</span></span>
<span id="cb3-55"><a href="#cb3-55"></a>unlabeledData <span class="op">=</span> spark.read.load(</span>
<span id="cb3-56"><a href="#cb3-56"></a>    unlabeledData,</span>
<span id="cb3-57"><a href="#cb3-57"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb3-58"><a href="#cb3-58"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb3-59"><a href="#cb3-59"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb3-60"><a href="#cb3-60"></a>)</span>
<span id="cb3-61"><a href="#cb3-61"></a></span>
<span id="cb3-62"><a href="#cb3-62"></a><span class="co">## Apply the same assembler we created before also on the unlabeled data</span></span>
<span id="cb3-63"><a href="#cb3-63"></a><span class="co">## to create the features column</span></span>
<span id="cb3-64"><a href="#cb3-64"></a>unlabeledDataDF <span class="op">=</span> assembler.transform(unlabeledData)</span>
<span id="cb3-65"><a href="#cb3-65"></a></span>
<span id="cb3-66"><a href="#cb3-66"></a><span class="co">## Make predictions on the unlabled data using the transform() method of the</span></span>
<span id="cb3-67"><a href="#cb3-67"></a><span class="co">## trained classification model transform uses only the content of 'features'</span></span>
<span id="cb3-68"><a href="#cb3-68"></a><span class="co">## to perform the predictions</span></span>
<span id="cb3-69"><a href="#cb3-69"></a>predictionsDF <span class="op">=</span> classificationModel.transform(unlabeledDataDF)</span>
<span id="cb3-70"><a href="#cb3-70"></a></span>
<span id="cb3-71"><a href="#cb3-71"></a><span class="co">## The returned DataFrame has the following schema (attributes)</span></span>
<span id="cb3-72"><a href="#cb3-72"></a><span class="co">## - attr1</span></span>
<span id="cb3-73"><a href="#cb3-73"></a><span class="co">## - attr2</span></span>
<span id="cb3-74"><a href="#cb3-74"></a><span class="co">## - attr3</span></span>
<span id="cb3-75"><a href="#cb3-75"></a><span class="co">## - features: vector (values of the attributes)</span></span>
<span id="cb3-76"><a href="#cb3-76"></a><span class="co">## - label: double (value of the class label)</span></span>
<span id="cb3-77"><a href="#cb3-77"></a><span class="co">## - rawPrediction: vector (nullable = true)</span></span>
<span id="cb3-78"><a href="#cb3-78"></a><span class="co">## - probability: vector (The i-th cell contains the probability that </span></span>
<span id="cb3-79"><a href="#cb3-79"></a><span class="co">## the current record belongs to the i-th class</span></span>
<span id="cb3-80"><a href="#cb3-80"></a><span class="co">## - prediction: double (the predicted class label)</span></span>
<span id="cb3-81"><a href="#cb3-81"></a></span>
<span id="cb3-82"><a href="#cb3-82"></a><span class="co">## Select only the original features (i.e., the value of the original attributes</span></span>
<span id="cb3-83"><a href="#cb3-83"></a><span class="co">## attr1, attr2, attr3) and the predicted class for each record</span></span>
<span id="cb3-84"><a href="#cb3-84"></a>predictions <span class="op">=</span> predictionsDF.select(<span class="st">"attr1"</span>, <span class="st">"attr2"</span>, <span class="st">"attr3"</span>, <span class="st">"prediction"</span>)</span>
<span id="cb3-85"><a href="#cb3-85"></a></span>
<span id="cb3-86"><a href="#cb3-86"></a><span class="co">## Save the result in an HDFS output folder</span></span>
<span id="cb3-87"><a href="#cb3-87"></a>predictions.write.csv(outputPath, header<span class="op">=</span><span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="pipelines" class="level4">
<h4 class="anchored" data-anchor-id="pipelines">Pipelines</h4>
<p>In the previous solution the same preprocessing steps were applied on both training and unlabeled data (the same assembler on both input data). It is possible to use a pipeline to specify the common phases we apply on both input data sets.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> LogisticRegression</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> Pipeline</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> PipelineModel</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">## input and output folders</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>trainingData <span class="op">=</span> <span class="st">"ex_data/trainingData.csv"</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>unlabeledData <span class="op">=</span> <span class="st">"ex_data/unlabeledData.csv"</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>outputPath <span class="op">=</span> <span class="st">"predictionsLR/"</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">## *************************</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">## Training step</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">## *************************</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">## Create a DataFrame from trainingData.csv</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">## Training data in raw format</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>trainingData <span class="op">=</span> spark.read.load(</span>
<span id="cb4-18"><a href="#cb4-18"></a>    trainingData,</span>
<span id="cb4-19"><a href="#cb4-19"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb4-20"><a href="#cb4-20"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb4-21"><a href="#cb4-21"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>)</span>
<span id="cb4-23"><a href="#cb4-23"></a></span>
<span id="cb4-24"><a href="#cb4-24"></a><span class="co">## Define an assembler to create a column (features) of type Vector</span></span>
<span id="cb4-25"><a href="#cb4-25"></a><span class="co">## containing the double values associated with columns attr1, attr2, attr3</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>assembler <span class="op">=</span> VectorAssembler(</span>
<span id="cb4-27"><a href="#cb4-27"></a>    inputCols<span class="op">=</span>[<span class="st">"attr1"</span>,<span class="st">"attr2"</span>,<span class="st">"attr3"</span>],</span>
<span id="cb4-28"><a href="#cb4-28"></a>    outputCol<span class="op">=</span><span class="st">"features"</span></span>
<span id="cb4-29"><a href="#cb4-29"></a>)</span>
<span id="cb4-30"><a href="#cb4-30"></a></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="co">## Create a LogisticRegression object</span></span>
<span id="cb4-32"><a href="#cb4-32"></a><span class="co">## LogisticRegression is an Estimator that is used to</span></span>
<span id="cb4-33"><a href="#cb4-33"></a><span class="co">## create a classification model based on logistic regression.</span></span>
<span id="cb4-34"><a href="#cb4-34"></a>lr <span class="op">=</span> LogisticRegression()</span>
<span id="cb4-35"><a href="#cb4-35"></a></span>
<span id="cb4-36"><a href="#cb4-36"></a><span class="co">## Set the values of the parameters of the</span></span>
<span id="cb4-37"><a href="#cb4-37"></a><span class="co">## Logistic Regression algorithm using the setter methods.</span></span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="co">## There is one set method for each parameter</span></span>
<span id="cb4-39"><a href="#cb4-39"></a><span class="co">## For example, we are setting the number of maximum iterations to 10</span></span>
<span id="cb4-40"><a href="#cb4-40"></a><span class="co">## and the regularization parameter to 0.01</span></span>
<span id="cb4-41"><a href="#cb4-41"></a>lr.setMaxIter(<span class="dv">10</span>)</span>
<span id="cb4-42"><a href="#cb4-42"></a>lr.setRegParam(<span class="fl">0.01</span>)</span>
<span id="cb4-43"><a href="#cb4-43"></a></span>
<span id="cb4-44"><a href="#cb4-44"></a><span class="co">## Define a pipeline that is used to create the logistic regression</span></span>
<span id="cb4-45"><a href="#cb4-45"></a><span class="co">## model on the training data. The pipeline includes also</span></span>
<span id="cb4-46"><a href="#cb4-46"></a><span class="co">## the preprocessing step</span></span>
<span id="cb4-47"><a href="#cb4-47"></a><span class="co">#pipeline = Pipeline().setStages([assembler, lr]) # &lt;1&gt;</span></span>
<span id="cb4-48"><a href="#cb4-48"></a></span>
<span id="cb4-49"><a href="#cb4-49"></a><span class="co">## Execute the pipeline on the training data to build the</span></span>
<span id="cb4-50"><a href="#cb4-50"></a><span class="co">## classification model</span></span>
<span id="cb4-51"><a href="#cb4-51"></a>classificationModel <span class="op">=</span> pipeline.fit(trainingData)</span>
<span id="cb4-52"><a href="#cb4-52"></a></span>
<span id="cb4-53"><a href="#cb4-53"></a><span class="co">## Now, the classification model can be used to predict the class label</span></span>
<span id="cb4-54"><a href="#cb4-54"></a><span class="co">## of new unlabeled data</span></span>
<span id="cb4-55"><a href="#cb4-55"></a></span>
<span id="cb4-56"><a href="#cb4-56"></a><span class="co">## *************************</span></span>
<span id="cb4-57"><a href="#cb4-57"></a><span class="co">## Prediction step</span></span>
<span id="cb4-58"><a href="#cb4-58"></a><span class="co">## *************************</span></span>
<span id="cb4-59"><a href="#cb4-59"></a><span class="co">## Create a DataFrame from unlabeledData.csv</span></span>
<span id="cb4-60"><a href="#cb4-60"></a><span class="co">## Unlabeled data in raw format</span></span>
<span id="cb4-61"><a href="#cb4-61"></a>unlabeledData <span class="op">=</span> spark.read.load(</span>
<span id="cb4-62"><a href="#cb4-62"></a>    unlabeledData,</span>
<span id="cb4-63"><a href="#cb4-63"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb4-64"><a href="#cb4-64"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb4-65"><a href="#cb4-65"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb4-66"><a href="#cb4-66"></a>)</span>
<span id="cb4-67"><a href="#cb4-67"></a></span>
<span id="cb4-68"><a href="#cb4-68"></a><span class="co">## Make predictions on the unlabled data using the transform() </span></span>
<span id="cb4-69"><a href="#cb4-69"></a><span class="co">## method of the trained classification model transform uses only </span></span>
<span id="cb4-70"><a href="#cb4-70"></a><span class="co">## the content of 'features' to perform the predictions. The model </span></span>
<span id="cb4-71"><a href="#cb4-71"></a><span class="co">## is associated with the pipeline and hence also the assembler is executed</span></span>
<span id="cb4-72"><a href="#cb4-72"></a>predictions <span class="op">=</span> classificationModel.transform(unlabeledData)</span>
<span id="cb4-73"><a href="#cb4-73"></a></span>
<span id="cb4-74"><a href="#cb4-74"></a><span class="co">## The returned DataFrame has the following schema (attributes)</span></span>
<span id="cb4-75"><a href="#cb4-75"></a><span class="co">## - attr1</span></span>
<span id="cb4-76"><a href="#cb4-76"></a><span class="co">## - attr2</span></span>
<span id="cb4-77"><a href="#cb4-77"></a><span class="co">## - attr3</span></span>
<span id="cb4-78"><a href="#cb4-78"></a><span class="co">## - features: vector (values of the attributes)</span></span>
<span id="cb4-79"><a href="#cb4-79"></a><span class="co">## - label: double (value of the class label)</span></span>
<span id="cb4-80"><a href="#cb4-80"></a><span class="co">## - rawPrediction: vector (nullable = true)</span></span>
<span id="cb4-81"><a href="#cb4-81"></a><span class="co">## - probability: vector (The i-th cell contains the probability that the current</span></span>
<span id="cb4-82"><a href="#cb4-82"></a><span class="co">## record belongs to the i-th class</span></span>
<span id="cb4-83"><a href="#cb4-83"></a><span class="co">## - prediction: double (the predicted class label)</span></span>
<span id="cb4-84"><a href="#cb4-84"></a><span class="co">## Select only the original features (i.e., the value of the original attributes</span></span>
<span id="cb4-85"><a href="#cb4-85"></a><span class="co">## attr1, attr2, attr3) and the predicted class for each record</span></span>
<span id="cb4-86"><a href="#cb4-86"></a>predictions <span class="op">=</span> predictionsDF.select(<span class="st">"attr1"</span>,<span class="st">"attr2"</span>,<span class="st">"attr3"</span>,<span class="st">"prediction"</span>)</span>
<span id="cb4-87"><a href="#cb4-87"></a></span>
<span id="cb4-88"><a href="#cb4-88"></a><span class="co">## Save the result in an HDFS output folder</span></span>
<span id="cb4-89"><a href="#cb4-89"></a>predictions.write.csv(outputPath, header<span class="op">=</span><span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>assembler</code>: the sequence of transformers and estimators to apply on the input data</li>
</ol>
</div>
</div>
</div>
</section>
<section id="decision-trees-and-structured-data" class="level4">
<h4 class="anchored" data-anchor-id="decision-trees-and-structured-data">Decision trees and structured data</h4>
<p>The following paragraphs show how to</p>
<ul>
<li>Create a classification model based on the decision tree algorithm on structured data: the model is inferred by analyzing the training data, i.e., the example records/data points for which the value of the class label is known;</li>
<li>Apply the model to new unlabeled data: the inferred model is applied to predict the value of the class label of new unlabeled records/data points.</li>
</ul>
<p>The same example structured data already used in the running example related to the logistic regression algorithm are used also in this example related to the decision tree algorithm. The main steps are the same of the previous example, the only difference is the definition and configuration of the used classification algorithm.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> DecisionTreeClassifier</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> Pipeline</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> PipelineModel</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">## input and output folders</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>trainingData <span class="op">=</span> <span class="st">"ex_data/trainingData.csv"</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>unlabeledData <span class="op">=</span> <span class="st">"ex_data/unlabeledData.csv"</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>outputPath <span class="op">=</span> <span class="st">"predictionsLR/"</span></span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">## *************************</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">## Training step</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co">## *************************</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">## Create a DataFrame from trainingData.csv</span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="co">## Training data in raw format</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>trainingData <span class="op">=</span> spark.read.load(</span>
<span id="cb5-18"><a href="#cb5-18"></a>    trainingData,</span>
<span id="cb5-19"><a href="#cb5-19"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb5-20"><a href="#cb5-20"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb5-21"><a href="#cb5-21"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>)</span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="co">## Define an assembler to create a column (features) of type Vector</span></span>
<span id="cb5-25"><a href="#cb5-25"></a><span class="co">## containing the double values associated with columns attr1, attr2, attr3</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>assembler <span class="op">=</span> VectorAssembler(</span>
<span id="cb5-27"><a href="#cb5-27"></a>    inputCols<span class="op">=</span>[<span class="st">"attr1"</span>,<span class="st">"attr2"</span>,<span class="st">"attr3"</span>],</span>
<span id="cb5-28"><a href="#cb5-28"></a>    outputCol<span class="op">=</span><span class="st">"features"</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>)</span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="co">## Create a DecisionTreeClassifier object.</span></span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="co">## DecisionTreeClassifier is an Estimator that is used to</span></span>
<span id="cb5-33"><a href="#cb5-33"></a><span class="co">## create a classification model based on decision trees.</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>dt <span class="op">=</span> DecisionTreeClassifier()</span>
<span id="cb5-35"><a href="#cb5-35"></a></span>
<span id="cb5-36"><a href="#cb5-36"></a><span class="co">## We can set the values of the parameters of the Decision Tree</span></span>
<span id="cb5-37"><a href="#cb5-37"></a><span class="co">## For example we can set the measure that is used to decide if a</span></span>
<span id="cb5-38"><a href="#cb5-38"></a><span class="co">## node must be split. In this case we set gini index</span></span>
<span id="cb5-39"><a href="#cb5-39"></a>dt.setImpurity(<span class="st">"gini"</span>)</span>
<span id="cb5-40"><a href="#cb5-40"></a></span>
<span id="cb5-41"><a href="#cb5-41"></a><span class="co">## Define a pipeline that is used to create the decision tree</span></span>
<span id="cb5-42"><a href="#cb5-42"></a><span class="co">## model on the training data. The pipeline includes also</span></span>
<span id="cb5-43"><a href="#cb5-43"></a><span class="co">## the preprocessing step</span></span>
<span id="cb5-44"><a href="#cb5-44"></a><span class="co">#pipeline = Pipeline().setStages([assembler, dt]) # &lt;1&gt;</span></span>
<span id="cb5-45"><a href="#cb5-45"></a></span>
<span id="cb5-46"><a href="#cb5-46"></a><span class="co">## Execute the pipeline on the training data to build the</span></span>
<span id="cb5-47"><a href="#cb5-47"></a><span class="co">## classification model</span></span>
<span id="cb5-48"><a href="#cb5-48"></a>classificationModel <span class="op">=</span> pipeline.fit(trainingData)</span>
<span id="cb5-49"><a href="#cb5-49"></a></span>
<span id="cb5-50"><a href="#cb5-50"></a><span class="co">## Now, the classification model can be used to predict the class label</span></span>
<span id="cb5-51"><a href="#cb5-51"></a><span class="co">## of new unlabeled data</span></span>
<span id="cb5-52"><a href="#cb5-52"></a></span>
<span id="cb5-53"><a href="#cb5-53"></a><span class="co">## *************************</span></span>
<span id="cb5-54"><a href="#cb5-54"></a><span class="co">## Prediction step</span></span>
<span id="cb5-55"><a href="#cb5-55"></a><span class="co">## *************************</span></span>
<span id="cb5-56"><a href="#cb5-56"></a><span class="co">## Create a DataFrame from unlabeledData.csv</span></span>
<span id="cb5-57"><a href="#cb5-57"></a><span class="co">## Unlabeled data in raw format</span></span>
<span id="cb5-58"><a href="#cb5-58"></a>unlabeledData <span class="op">=</span> spark.read.load(unlabeledData,<span class="op">\</span></span>
<span id="cb5-59"><a href="#cb5-59"></a><span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>, header<span class="op">=</span><span class="va">True</span>, inferSchema<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-60"><a href="#cb5-60"></a></span>
<span id="cb5-61"><a href="#cb5-61"></a><span class="co">## Make predictions on the unlabled data using the transform() method of the</span></span>
<span id="cb5-62"><a href="#cb5-62"></a><span class="co">## trained classification model transform uses only the content of 'features'</span></span>
<span id="cb5-63"><a href="#cb5-63"></a><span class="co">## to perform the predictions. The model is associated with the pipeline and hence</span></span>
<span id="cb5-64"><a href="#cb5-64"></a><span class="co">## also the assembler is executed</span></span>
<span id="cb5-65"><a href="#cb5-65"></a>predictions <span class="op">=</span> classificationModel.transform(unlabeledData)</span>
<span id="cb5-66"><a href="#cb5-66"></a></span>
<span id="cb5-67"><a href="#cb5-67"></a><span class="co">## The returned DataFrame has the following schema (attributes)</span></span>
<span id="cb5-68"><a href="#cb5-68"></a><span class="co">## - attr1</span></span>
<span id="cb5-69"><a href="#cb5-69"></a><span class="co">## - attr2</span></span>
<span id="cb5-70"><a href="#cb5-70"></a><span class="co">## - attr3</span></span>
<span id="cb5-71"><a href="#cb5-71"></a><span class="co">## - features: vector (values of the attributes)</span></span>
<span id="cb5-72"><a href="#cb5-72"></a><span class="co">## - label: double (value of the class label)</span></span>
<span id="cb5-73"><a href="#cb5-73"></a><span class="co">## - rawPrediction: vector (nullable = true)</span></span>
<span id="cb5-74"><a href="#cb5-74"></a><span class="co">## - probability: vector (The i-th cell contains the probability that the current</span></span>
<span id="cb5-75"><a href="#cb5-75"></a><span class="co">## record belongs to the i-th class</span></span>
<span id="cb5-76"><a href="#cb5-76"></a><span class="co">## - prediction: double (the predicted class label)</span></span>
<span id="cb5-77"><a href="#cb5-77"></a><span class="co">## Select only the original features (i.e., the value of the original attributes</span></span>
<span id="cb5-78"><a href="#cb5-78"></a><span class="co">## attr1, attr2, attr3) and the predicted class for each record</span></span>
<span id="cb5-79"><a href="#cb5-79"></a>predictions <span class="op">=</span> predictionsDF.select(<span class="st">"attr1"</span>,<span class="st">"attr2"</span>,<span class="st">"attr3"</span>,<span class="st">"prediction"</span>)</span>
<span id="cb5-80"><a href="#cb5-80"></a></span>
<span id="cb5-81"><a href="#cb5-81"></a><span class="co">## Save the result in an HDFS output folder</span></span>
<span id="cb5-82"><a href="#cb5-82"></a>predictions.write.csv(outputPath, header<span class="op">=</span><span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>assembler</code>: the sequence of transformers and estimators to apply on the input data. A decision tree algorithm is used in this case.</li>
</ol>
</div>
</div>
</div>
</section>
</section>
<section id="categorical-class-labels" class="level3">
<h3 class="anchored" data-anchor-id="categorical-class-labels">Categorical class labels</h3>
<p>Usually the class label is a categorical value (i.e., a string). However, as reported before, Spark MLlib works only with numerical values and hence categorical class label values must be mapped to integer (and then double) values: processing and postprocessing steps are used to manage this transformation.</p>
<p>Consider the following input training data</p>
<table class="table">
<thead>
<tr class="header">
<th>categoricalLabel</th>
<th>Attr1</th>
<th>Attr2</th>
<th>Attr3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Positive</td>
<td><span class="math inline">\(0.0\)</span></td>
<td><span class="math inline">\(1.1\)</span></td>
<td><span class="math inline">\(0.1\)</span></td>
</tr>
<tr class="even">
<td>Negative</td>
<td><span class="math inline">\(2.0\)</span></td>
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\(-1.0\)</span></td>
</tr>
<tr class="odd">
<td>Negative</td>
<td><span class="math inline">\(2.0\)</span></td>
<td><span class="math inline">\(1.3\)</span></td>
<td><span class="math inline">\(1.0\)</span></td>
</tr>
</tbody>
</table>
<p>A modified input DataFrame must be generated as input for the MLlib classification algorithms</p>
<table class="table">
<thead>
<tr class="header">
<th>label</th>
<th>features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\([0.0,1.1,0.1]\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(1.0\)</span></td>
<td><span class="math inline">\([2.0,1.0,-1.0]\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(0.0\)</span></td>
<td><span class="math inline">\([2.0,1.3,1.0]\)</span></td>
</tr>
</tbody>
</table>
<p>Notice that the categorical values of “categoricalLabel” (the class label column) must mapped to integer data values (finally casted to doubles).</p>
<section id="stringindexer-and-indextostring" class="level4">
<h4 class="anchored" data-anchor-id="stringindexer-and-indextostring"><code>StringIndexer</code> and <code>IndexToString</code></h4>
<p>The Estimator <code>StringIndexer</code> and the Transformer <code>IndexToString</code> support the transformation of categorical class label into numerical one and vice versa:</p>
<ul>
<li><code>StringIndexer</code> maps each categorical value of the class label to an integer (then casted to a double);</li>
<li><code>IndexToString</code> is used to perform the opposite operation.</li>
</ul>
<p>All in all, these are the main steps</p>
<ol type="1">
<li>Use <code>StringIndexer</code> to extend the input DataFrame with a new column, called “label”, containing the numerical representation of the class label column;</li>
<li>Create a column, called “features”, of type vector containing the predictive features;</li>
<li>Infer a classification model by using a classification algorithm (e.g., Decision Tree, Logistic regression);</li>
<li>Apply the model on a set of unlabeled data to predict their numerical class label;</li>
<li>Use <code>IndexToString</code> to convert the predicted numerical class label values to the original categorical values.</li>
</ol>
<p>Notice that the model is built by considering only the values of features and label. All the other columns are not considered by the classification algorithm during the generation of the prediction model.</p>
<section id="training-data-1" class="level5">
<h5 class="anchored" data-anchor-id="training-data-1">Training data</h5>
<p>Given the following input training file</p>
<pre><code>categoricalLabel,attr1,attr2,attr3
Positive,0.0,1.1,0.1
Negative,2.0,1.0,-1.0
Negative,2.0,1.3,1.0</code></pre>
<p>The initial training DataFrame will be</p>
<table class="table">
<thead>
<tr class="header">
<th>categoricalLabel</th>
<th>features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Positive</td>
<td><span class="math inline">\([0.0,1.1,0.1]\)</span></td>
</tr>
<tr class="even">
<td>Negative</td>
<td><span class="math inline">\([2.0,1.0,-1.0]\)</span></td>
</tr>
<tr class="odd">
<td>Negative</td>
<td><span class="math inline">\([2.0,1.3,1.0]\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>The type of “categoricalLabel” is String</li>
<li>The type of “features” is Vector</li>
</ul>
<p>After applying <code>StringIndexer</code>, the training DataFrame will be</p>
<table class="table">
<thead>
<tr class="header">
<th>categoricalLabel</th>
<th>features</th>
<th>label!</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Positive</td>
<td><span class="math inline">\([0.0,1.1,0.1]\)</span></td>
<td><span class="math inline">\(1.0\)</span></td>
</tr>
<tr class="even">
<td>Negative</td>
<td><span class="math inline">\([2.0,1.0,-1.0]\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
</tr>
<tr class="odd">
<td>Negative</td>
<td><span class="math inline">\([2.0,1.3,1.0]\)</span></td>
<td><span class="math inline">\(0.0\)</span></td>
</tr>
</tbody>
</table>
<p>“label” contains the mapping generated by <code>StringIndexer</code>:</p>
<ul>
<li>“Positive”: <span class="math inline">\(1.0\)</span></li>
<li>“Negative”: <span class="math inline">\(0.0\)</span></li>
</ul>
</section>
<section id="unalabeled-data" class="level5">
<h5 class="anchored" data-anchor-id="unalabeled-data">Unalabeled data</h5>
<p>Given the input unlabeled data file</p>
<pre><code>categoricalLabel,attr1,attr2,attr3
,-1.0,1.5,1.3
,3.0,2.0,-0.1
,0.0,2.2,-1.5</code></pre>
<p>The initial unlabeled DataFrame will be</p>
<table class="table">
<thead>
<tr class="header">
<th>categoricalLabel</th>
<th>features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>null</td>
<td><span class="math inline">\([-1.0,1.5,1.3]\)</span></td>
</tr>
<tr class="even">
<td>null</td>
<td><span class="math inline">\([3.0,2.0,-0.1]\)</span></td>
</tr>
<tr class="odd">
<td>null</td>
<td><span class="math inline">\([0.0,2.2,-1.5]\)</span></td>
</tr>
</tbody>
</table>
<p>After performing the prediction, and applying <code>IndexToString</code>, the output DataFrame will be</p>
<table class="table">
<thead>
<tr class="header">
<th>categoricalLabel</th>
<th>features</th>
<th>label</th>
<th>prediction</th>
<th>predictedLabel</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>…</td>
<td><span class="math inline">\([-1.0,1.5,1.3]\)</span></td>
<td>…</td>
<td><span class="math inline">\(1.0\)</span></td>
<td>Positive</td>
<td></td>
</tr>
<tr class="even">
<td>…</td>
<td><span class="math inline">\([3.0,2.0,-0.1]\)</span></td>
<td>…</td>
<td><span class="math inline">\(0.0\)</span></td>
<td>Negative</td>
<td></td>
</tr>
<tr class="odd">
<td>…</td>
<td><span class="math inline">\([0.0,2.2,-1.5]\)</span></td>
<td>…</td>
<td><span class="math inline">\(1.0\)</span></td>
<td>Negative</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>“prediction” contains the predicted label, expressed as a number</li>
<li>“predictedLabel” contains the predicted label, expressed as a category (original name)</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In this example, the input training data is stored in a text file that contains one record/data point per line, and the records/data points are structured data with a fixed number of attributes (four)</p>
<ul>
<li>One attribute is the class label (“categoricalLabel”): this is a categorical attribute that can assume two values, “Positive” or “Negative”;</li>
<li>The other three attributes (“attr1”, “attr2”, “attr3”) are the predictive attributes that are used to predict the value of the class label.</li>
</ul>
<p>The input file has the header line.</p>
<p>The file containing the unlabeled data has the same format of the training data file, however the first column is empty because the class label is unknown.</p>
<p>The goal is to predict the class label value of each unlabeled data by applying the classification model that has been inferred on the training data.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> StringIndexer</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> IndexToString</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> DecisionTreeClassifier</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> Pipeline</span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> PipelineModel</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">## input and output folders</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>trainingData <span class="op">=</span> <span class="st">"ex_dataCategorical/trainingData.csv"</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>unlabeledData <span class="op">=</span> <span class="st">"ex_dataCategorical/unlabeledData.csv"</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>outputPath <span class="op">=</span> <span class="st">"predictionsDTCategoricalPipeline/"</span></span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="co">## *************************</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">## Training step</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="co">## *************************</span></span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="co">## Create a DataFrame from trainingData.csv</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co">## Training data in raw format</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>trainingData <span class="op">=</span> spark.read.load(trainingData,<span class="op">\</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>, header<span class="op">=</span><span class="va">True</span>, inferSchema<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-22"><a href="#cb8-22"></a></span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="co">## Define an assembler to create a column (features) of type Vector</span></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="co">## containing the double values associated with columns attr1, attr2, attr3</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>assembler <span class="op">=</span> VectorAssembler(</span>
<span id="cb8-26"><a href="#cb8-26"></a>    inputCols<span class="op">=</span>[<span class="st">"attr1"</span>,<span class="st">"attr2"</span>,<span class="st">"attr3"</span>],</span>
<span id="cb8-27"><a href="#cb8-27"></a>    outputCol<span class="op">=</span><span class="st">"features"</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>)</span>
<span id="cb8-29"><a href="#cb8-29"></a></span>
<span id="cb8-30"><a href="#cb8-30"></a><span class="co">## The StringIndexer Estimator is used to map each class label</span></span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="co">## value to an integer value (casted to a double).</span></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="co">## A new attribute called label is generated by applying</span></span>
<span id="cb8-33"><a href="#cb8-33"></a><span class="co">## transforming the content of the categoricalLabel attribute.</span></span>
<span id="cb8-34"><a href="#cb8-34"></a><span class="co">#labelIndexer = StringIndexer( # &lt;1&gt;</span></span>
<span id="cb8-35"><a href="#cb8-35"></a>    inputCol<span class="op">=</span><span class="st">"categoricalLabel"</span></span>
<span id="cb8-36"><a href="#cb8-36"></a>    outputCol<span class="op">=</span><span class="st">"label"</span>,</span>
<span id="cb8-37"><a href="#cb8-37"></a>    handleInvalid<span class="op">=</span><span class="st">"keep"</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>).fit(trainingData) </span>
<span id="cb8-39"><a href="#cb8-39"></a></span>
<span id="cb8-40"><a href="#cb8-40"></a><span class="co">## Create a DecisionTreeClassifier object.</span></span>
<span id="cb8-41"><a href="#cb8-41"></a><span class="co">## DecisionTreeClassifier is an Estimator that is used to</span></span>
<span id="cb8-42"><a href="#cb8-42"></a><span class="co">## create a classification model based on decision trees.</span></span>
<span id="cb8-43"><a href="#cb8-43"></a>dt <span class="op">=</span> DecisionTreeClassifier()</span>
<span id="cb8-44"><a href="#cb8-44"></a></span>
<span id="cb8-45"><a href="#cb8-45"></a><span class="co">## Set the values of the parameters of the Decision Tree</span></span>
<span id="cb8-46"><a href="#cb8-46"></a><span class="co">## For example set the measure that is used to decide if a</span></span>
<span id="cb8-47"><a href="#cb8-47"></a><span class="co">## node must be split.</span></span>
<span id="cb8-48"><a href="#cb8-48"></a><span class="co">## In this case we set gini index</span></span>
<span id="cb8-49"><a href="#cb8-49"></a>dt.setImpurity(<span class="st">"gini"</span>)</span>
<span id="cb8-50"><a href="#cb8-50"></a></span>
<span id="cb8-51"><a href="#cb8-51"></a><span class="co">## At the end of the pipeline we must convert indexed labels back</span></span>
<span id="cb8-52"><a href="#cb8-52"></a><span class="co">## to original labels (from numerical to string).</span></span>
<span id="cb8-53"><a href="#cb8-53"></a><span class="co">## The content of the prediction attribute is the index of the predicted class</span></span>
<span id="cb8-54"><a href="#cb8-54"></a><span class="co">## The original name of the predicted class is stored in the predictedLabel</span></span>
<span id="cb8-55"><a href="#cb8-55"></a><span class="co">## attribute.</span></span>
<span id="cb8-56"><a href="#cb8-56"></a><span class="co">## IndexToString creates a new column (called predictedLabel in</span></span>
<span id="cb8-57"><a href="#cb8-57"></a><span class="co">## this example) that is based on the content of the prediction column.</span></span>
<span id="cb8-58"><a href="#cb8-58"></a><span class="co">## prediction is a double while predictedLabel is a string</span></span>
<span id="cb8-59"><a href="#cb8-59"></a><span class="co">#labelConverter = IndexToString( # &lt;2&gt;</span></span>
<span id="cb8-60"><a href="#cb8-60"></a>    inputCol<span class="op">=</span><span class="st">"prediction"</span>,</span>
<span id="cb8-61"><a href="#cb8-61"></a>    outputCol<span class="op">=</span><span class="st">"predictedLabel"</span>,</span>
<span id="cb8-62"><a href="#cb8-62"></a>    labels<span class="op">=</span>labelIndexer.labels</span>
<span id="cb8-63"><a href="#cb8-63"></a>)</span>
<span id="cb8-64"><a href="#cb8-64"></a></span>
<span id="cb8-65"><a href="#cb8-65"></a><span class="co">## Define a pipeline that is used to create the decision tree</span></span>
<span id="cb8-66"><a href="#cb8-66"></a><span class="co">## model on the training data. The pipeline includes also</span></span>
<span id="cb8-67"><a href="#cb8-67"></a><span class="co">## the preprocessing and postprocessing steps</span></span>
<span id="cb8-68"><a href="#cb8-68"></a>pipeline <span class="op">=</span> Pipeline() \ </span>
<span id="cb8-69"><a href="#cb8-69"></a>    <span class="co">#.setStages([assembler, labelIndexer, dt, labelConverter]) # &lt;3&gt;</span></span>
<span id="cb8-70"><a href="#cb8-70"></a></span>
<span id="cb8-71"><a href="#cb8-71"></a><span class="co">## Execute the pipeline on the training data to build the</span></span>
<span id="cb8-72"><a href="#cb8-72"></a><span class="co">## classification model</span></span>
<span id="cb8-73"><a href="#cb8-73"></a>classificationModel <span class="op">=</span> pipeline.fit(trainingData)</span>
<span id="cb8-74"><a href="#cb8-74"></a></span>
<span id="cb8-75"><a href="#cb8-75"></a><span class="co">## Now, the classification model can be used to predict the class label</span></span>
<span id="cb8-76"><a href="#cb8-76"></a><span class="co">## of new unlabeled data</span></span>
<span id="cb8-77"><a href="#cb8-77"></a></span>
<span id="cb8-78"><a href="#cb8-78"></a><span class="co">## *************************</span></span>
<span id="cb8-79"><a href="#cb8-79"></a><span class="co">## Prediction step</span></span>
<span id="cb8-80"><a href="#cb8-80"></a><span class="co">## *************************</span></span>
<span id="cb8-81"><a href="#cb8-81"></a><span class="co">## Create a DataFrame from unlabeledData.csv</span></span>
<span id="cb8-82"><a href="#cb8-82"></a><span class="co">## Unlabeled data in raw format</span></span>
<span id="cb8-83"><a href="#cb8-83"></a>unlabeledData <span class="op">=</span> spark.read.load(</span>
<span id="cb8-84"><a href="#cb8-84"></a>    unlabeledData,</span>
<span id="cb8-85"><a href="#cb8-85"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb8-86"><a href="#cb8-86"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb8-87"><a href="#cb8-87"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb8-88"><a href="#cb8-88"></a>)</span>
<span id="cb8-89"><a href="#cb8-89"></a></span>
<span id="cb8-90"><a href="#cb8-90"></a><span class="co">## Make predictions on the unlabled data using the transform() method of the</span></span>
<span id="cb8-91"><a href="#cb8-91"></a><span class="co">## trained classification model transform uses only the content of 'features'</span></span>
<span id="cb8-92"><a href="#cb8-92"></a><span class="co">## to perform the predictions. The model is associated with the pipeline and hence</span></span>
<span id="cb8-93"><a href="#cb8-93"></a><span class="co">## also the assembler is executed</span></span>
<span id="cb8-94"><a href="#cb8-94"></a>predictions <span class="op">=</span> classificationModel.transform(unlabeledData)</span>
<span id="cb8-95"><a href="#cb8-95"></a></span>
<span id="cb8-96"><a href="#cb8-96"></a><span class="co">## The returned DataFrame has the following schema (attributes)</span></span>
<span id="cb8-97"><a href="#cb8-97"></a><span class="co">## - attr1: double (nullable = true)</span></span>
<span id="cb8-98"><a href="#cb8-98"></a><span class="co">## - attr2: double (nullable = true)</span></span>
<span id="cb8-99"><a href="#cb8-99"></a><span class="co">## - attr3: double (nullable = true)</span></span>
<span id="cb8-100"><a href="#cb8-100"></a><span class="co">## - features: vector (values of the attributes)</span></span>
<span id="cb8-101"><a href="#cb8-101"></a><span class="co">## - label: double (value of the class label)</span></span>
<span id="cb8-102"><a href="#cb8-102"></a><span class="co">## - rawPrediction: vector (nullable = true)</span></span>
<span id="cb8-103"><a href="#cb8-103"></a><span class="co">## - probability: vector (The i-th cell contains the probability that the</span></span>
<span id="cb8-104"><a href="#cb8-104"></a><span class="co">##   current record belongs to the i-th class</span></span>
<span id="cb8-105"><a href="#cb8-105"></a><span class="co">## - prediction: double (the predicted class label)</span></span>
<span id="cb8-106"><a href="#cb8-106"></a><span class="co">## - predictedLabel: string (nullable = true)</span></span>
<span id="cb8-107"><a href="#cb8-107"></a></span>
<span id="cb8-108"><a href="#cb8-108"></a><span class="co">## Select only the original features (i.e., the value of the original attributes</span></span>
<span id="cb8-109"><a href="#cb8-109"></a><span class="co">## attr1, attr2, attr3) and the predicted class for each record</span></span>
<span id="cb8-110"><a href="#cb8-110"></a>predictions <span class="op">=</span> predictionsDF <span class="op">\</span></span>
<span id="cb8-111"><a href="#cb8-111"></a>    <span class="co">#.select("attr1", "attr2", "attr3", "predictedLabel") # &lt;4&gt;</span></span>
<span id="cb8-112"><a href="#cb8-112"></a></span>
<span id="cb8-113"><a href="#cb8-113"></a><span class="co">## Save the result in an HDFS output folder</span></span>
<span id="cb8-114"><a href="#cb8-114"></a>predictions.write.csv(outputPath, header<span class="op">=</span><span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>This <code>StringIndexer</code> estimator is used to infer a transformer that maps the categorical values of column “categoricalLabel” to a set of integer values stored in the new column called “label”. The list of valid label values are extracted from the training data.</li>
<li>This <code>IndexToString</code> component is used to remap the numerical predictions available in the “prediction” column to the original categorical values that are stored in the new column called “predictedLabel”. The mapping of integer to original string value is the one of “labelIndexer”.</li>
<li>This <code>Pipeline</code> is composed of four steps.</li>
<li>The “predictedLabel” field is the column containing the predicted categorical class label for the unlabeled data.</li>
</ol>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="textual-data-management-and-classification" class="level3">
<h3 class="anchored" data-anchor-id="textual-data-management-and-classification">Textual data management and classification</h3>
<p>The following paragraphs show how to</p>
<ul>
<li>Create a classification model based on the logistic regression algorithm for textual documents: a set of specific preprocessing estimators and transformers are used to preprocess textual data.</li>
<li>Apply the model to new textual documents</li>
</ul>
<p>The input training dataset represents a textual document collection, where each line contains one document and its class</p>
<ul>
<li>The class label</li>
<li>A list of words (the text of the document)</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Given the following example training file</p>
<pre><code>Label,Text
1,The Spark system is based on scala
1,Spark is a new distributed system
0,Turin is a beautiful city
0,Turin is in the north of Italy</code></pre>
<p>It contains four textual documents, and each line contains two attributes, that are the class label (first attribute) and the text of the document (second attribute).</p>
<p>The input data before preprocessing, represented as a DataFrame, is</p>
<table class="table">
<thead>
<tr class="header">
<th>Label</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>The Spark system is based on scala</td>
</tr>
<tr class="even">
<td>1</td>
<td>Spark is a new distributed system</td>
</tr>
<tr class="odd">
<td>0</td>
<td>Turin is a beautiful city</td>
</tr>
<tr class="even">
<td>0</td>
<td>Turin is in the north of Italy</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>A set of preprocessing steps must be applied on the textual attribute before generating a classification model.</p>
<ol type="1">
<li>Since Spark ML algorithms work only on “Tables” and double values, the textual part of the input data must be translated in a set of attributes to represent the data as a table: usually a table with an attribute for each word is generated.</li>
<li>Many words are useless (e.g., conjunctions): stopwords are usually removed. In general,
<ul>
<li>the words appearing in almost all documents are not characterizing the data, and so they are not very important for the classification problem;</li>
<li>the words appearing in few documents allow to distinguish the content of those documents (and hence the class label) with respect to the others, and so they are very important for the classification problem.</li>
</ul></li>
<li>Traditionally a weight, based on the TF-IDF measure, is used to assign a difference importance to the words based on their frequency in the collection.</li>
</ol>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Input data after the preprocessing transformations (tokenization, stopword removal, TF-IDF computation)</p>
<table class="table">
<thead>
<tr class="header">
<th>Label</th>
<th>Spark</th>
<th>system</th>
<th>scala</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><span class="math inline">\(0.5\)</span></td>
<td><span class="math inline">\(0.3\)</span></td>
<td><span class="math inline">\(0.75\)</span></td>
<td>…</td>
</tr>
<tr class="even">
<td>1</td>
<td><span class="math inline">\(0.5\)</span></td>
<td><span class="math inline">\(0.3\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td>…</td>
</tr>
<tr class="odd">
<td>0</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td>…</td>
</tr>
<tr class="even">
<td>0</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>The DataFrame associated with the input data after the preprocessing transformations must contain, as usual, the columns</p>
<ul>
<li>label: class label value</li>
<li>features: the preprocessed version of the input text</li>
</ul>
<p>There are also some other intermediate columns, related to applied transformations, but they are not considered by the classification algorithm.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The DataFrame associated with the input data after the preprocessing transformations</p>
<table class="table">
<thead>
<tr class="header">
<th>label</th>
<th>features</th>
<th>text</th>
<th>…</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><span class="math inline">\([0.5,0.3,0.75,...]\)</span></td>
<td>The Spark system is based on scala</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="even">
<td>1</td>
<td><span class="math inline">\([0.5,0.3,0,...]\)</span></td>
<td>Spark is a new distributed system</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="odd">
<td>0</td>
<td><span class="math inline">\([0,0,0,...]\)</span></td>
<td>Turin is a beautiful city</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="even">
<td>0</td>
<td><span class="math inline">\([0,0,0,...]\)</span></td>
<td>Turin is in the north of Italy</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Only “label” and “features” are considered by the classification algorithm.</p>
</div>
</div>
</div>
<p>In the following solution we will use a set of new Transformers to prepare input data</p>
<ul>
<li><code>Tokenizer</code>: to split the input text in words;</li>
<li><code>StopWordsRemover</code>: to remove stopwords;</li>
<li><code>HashingTF</code>: to compute the (approximate) term frequency of each input term;</li>
<li><code>IDF</code>: to compute the inverse document frequency of each input word.</li>
</ul>
<p>The input data (training and unlabeled data) are stored in input csv files. Each line contains two attributes:</p>
<ul>
<li>The class label (label)</li>
<li>The text of the document (text)</li>
</ul>
<p>We infer a linear regression model on the training data and apply the model on the unlabeled data.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> Tokenizer</span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> StopWordsRemover</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> HashingTF</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> IDF</span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> LogisticRegression</span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> Pipeline</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> PipelineModel</span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="co">## input and output folders</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>trainingData <span class="op">=</span> <span class="st">"ex_dataText/trainingData.csv"</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>unlabeledData <span class="op">=</span> <span class="st">"ex_dataText/unlabeledData.csv"</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>outputPath <span class="op">=</span> <span class="st">"predictionsLRPipelineText/"</span></span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="co">## *************************</span></span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="co">## Training step</span></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="co">## *************************</span></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="co">## Create a DataFrame from trainingData.csv</span></span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="co">## Training data in raw format</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>trainingData <span class="op">=</span> spark.read.load(</span>
<span id="cb10-22"><a href="#cb10-22"></a>    trainingData,</span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb10-24"><a href="#cb10-24"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb10-25"><a href="#cb10-25"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>)</span>
<span id="cb10-27"><a href="#cb10-27"></a></span>
<span id="cb10-28"><a href="#cb10-28"></a><span class="co">## Configure an ML pipeline, which consists of five stages:</span></span>
<span id="cb10-29"><a href="#cb10-29"></a><span class="co">## tokenizer -&gt; split sentences in set of words</span></span>
<span id="cb10-30"><a href="#cb10-30"></a><span class="co">## remover -&gt; remove stopwords</span></span>
<span id="cb10-31"><a href="#cb10-31"></a><span class="co">## hashingTF -&gt; map set of words to a fixed-length feature vectors (each</span></span>
<span id="cb10-32"><a href="#cb10-32"></a><span class="co">## word becomes a feature and the value of the feature is the frequency of</span></span>
<span id="cb10-33"><a href="#cb10-33"></a><span class="co">## the word in the sentence)</span></span>
<span id="cb10-34"><a href="#cb10-34"></a><span class="co">## idf -&gt; compute the idf component of the TF-IDF measure</span></span>
<span id="cb10-35"><a href="#cb10-35"></a><span class="co">## lr -&gt; logistic regression classification algorithm</span></span>
<span id="cb10-36"><a href="#cb10-36"></a><span class="co">## The Tokenizer splits each sentence in a set of words.</span></span>
<span id="cb10-37"><a href="#cb10-37"></a><span class="co">## It analyzes the content of column "text" and adds the</span></span>
<span id="cb10-38"><a href="#cb10-38"></a><span class="co">## new column "words" in the returned DataFrame</span></span>
<span id="cb10-39"><a href="#cb10-39"></a>tokenizer <span class="op">=</span> Tokenizer() <span class="op">\</span></span>
<span id="cb10-40"><a href="#cb10-40"></a>    .setInputCol(<span class="st">"text"</span>) <span class="op">\</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>    .setOutputCol(<span class="st">"words"</span>)</span>
<span id="cb10-42"><a href="#cb10-42"></a></span>
<span id="cb10-43"><a href="#cb10-43"></a><span class="co">## Remove stopwords.</span></span>
<span id="cb10-44"><a href="#cb10-44"></a><span class="co">## The StopWordsRemover component returns a new DataFrame with</span></span>
<span id="cb10-45"><a href="#cb10-45"></a><span class="co">## a new column called "filteredWords". "filteredWords" is generated</span></span>
<span id="cb10-46"><a href="#cb10-46"></a><span class="co">## by removing the stopwords from the content of column "words"</span></span>
<span id="cb10-47"><a href="#cb10-47"></a>remover <span class="op">=</span> StopWordsRemover() <span class="op">\</span></span>
<span id="cb10-48"><a href="#cb10-48"></a>    .setInputCol(<span class="st">"words"</span>) <span class="op">\</span></span>
<span id="cb10-49"><a href="#cb10-49"></a>    .setOutputCol(<span class="st">"filteredWords"</span>)</span>
<span id="cb10-50"><a href="#cb10-50"></a></span>
<span id="cb10-51"><a href="#cb10-51"></a><span class="co">## Map words to a features</span></span>
<span id="cb10-52"><a href="#cb10-52"></a><span class="co">## Each word in filteredWords must become a feature in a Vector object</span></span>
<span id="cb10-53"><a href="#cb10-53"></a><span class="co">## The HashingTF Transformer can be used to perform this operation.</span></span>
<span id="cb10-54"><a href="#cb10-54"></a><span class="co">## This operations is based on a hash function and can potentially</span></span>
<span id="cb10-55"><a href="#cb10-55"></a><span class="co">## map two different words to the same "feature". The number of conflicts</span></span>
<span id="cb10-56"><a href="#cb10-56"></a><span class="co">## in influenced by the value of the numFeatures parameter.</span></span>
<span id="cb10-57"><a href="#cb10-57"></a><span class="co">## The "feature" version of the words is stored in Column "rawFeatures".</span></span>
<span id="cb10-58"><a href="#cb10-58"></a><span class="co">## Each feature, for a document, contains the number of occurrences</span></span>
<span id="cb10-59"><a href="#cb10-59"></a><span class="co">## of that feature in the document (TF component of the TF-IDF measure)</span></span>
<span id="cb10-60"><a href="#cb10-60"></a>hashingTF <span class="op">=</span> HashingTF() <span class="op">\</span></span>
<span id="cb10-61"><a href="#cb10-61"></a>    .setNumFeatures(<span class="dv">1000</span>) <span class="op">\</span></span>
<span id="cb10-62"><a href="#cb10-62"></a>    .setInputCol(<span class="st">"filteredWords"</span>) <span class="op">\</span></span>
<span id="cb10-63"><a href="#cb10-63"></a>    .setOutputCol(<span class="st">"rawFeatures"</span>)</span>
<span id="cb10-64"><a href="#cb10-64"></a></span>
<span id="cb10-65"><a href="#cb10-65"></a><span class="co">## Apply the IDF transformation/computation.</span></span>
<span id="cb10-66"><a href="#cb10-66"></a><span class="co">## Update the weight associated with each feature by considering also the</span></span>
<span id="cb10-67"><a href="#cb10-67"></a><span class="co">## inverse document frequency component. The returned new column</span></span>
<span id="cb10-68"><a href="#cb10-68"></a><span class="co">## is called "features", that is the standard name for the column that</span></span>
<span id="cb10-69"><a href="#cb10-69"></a><span class="co">## contains the predictive features used to create a classification model</span></span>
<span id="cb10-70"><a href="#cb10-70"></a>idf <span class="op">=</span> IDF() <span class="op">\</span></span>
<span id="cb10-71"><a href="#cb10-71"></a>    .setInputCol(<span class="st">"rawFeatures"</span>) <span class="op">\</span></span>
<span id="cb10-72"><a href="#cb10-72"></a>    .setOutputCol(<span class="st">"features"</span>)</span>
<span id="cb10-73"><a href="#cb10-73"></a></span>
<span id="cb10-74"><a href="#cb10-74"></a><span class="co">## Create a classification model based on the logistic regression algorithm</span></span>
<span id="cb10-75"><a href="#cb10-75"></a><span class="co">## We can set the values of the parameters of the</span></span>
<span id="cb10-76"><a href="#cb10-76"></a><span class="co">## Logistic Regression algorithm using the setter methods.</span></span>
<span id="cb10-77"><a href="#cb10-77"></a>lr <span class="op">=</span> LogisticRegression() <span class="op">\</span></span>
<span id="cb10-78"><a href="#cb10-78"></a>    .setMaxIter(<span class="dv">10</span>) <span class="op">\</span></span>
<span id="cb10-79"><a href="#cb10-79"></a>    .setRegParam(<span class="fl">0.01</span>)</span>
<span id="cb10-80"><a href="#cb10-80"></a></span>
<span id="cb10-81"><a href="#cb10-81"></a><span class="co">## Define the pipeline that is used to create the logistic regression</span></span>
<span id="cb10-82"><a href="#cb10-82"></a><span class="co">## model on the training data.</span></span>
<span id="cb10-83"><a href="#cb10-83"></a><span class="co">## In this case the pipeline is composed of five steps</span></span>
<span id="cb10-84"><a href="#cb10-84"></a><span class="co">## - text tokenizer</span></span>
<span id="cb10-85"><a href="#cb10-85"></a><span class="co">## - stopword removal</span></span>
<span id="cb10-86"><a href="#cb10-86"></a><span class="co">## - TF-IDF computation (performed in two steps)</span></span>
<span id="cb10-87"><a href="#cb10-87"></a><span class="co">## - Logistic regression model generation</span></span>
<span id="cb10-88"><a href="#cb10-88"></a>pipeline <span class="op">=</span> Pipeline()<span class="op">\</span></span>
<span id="cb10-89"><a href="#cb10-89"></a>    .setStages([tokenizer, remover, hashingTF, idf, lr])</span>
<span id="cb10-90"><a href="#cb10-90"></a></span>
<span id="cb10-91"><a href="#cb10-91"></a><span class="co">## Execute the pipeline on the training data to build the</span></span>
<span id="cb10-92"><a href="#cb10-92"></a><span class="co">## classification model</span></span>
<span id="cb10-93"><a href="#cb10-93"></a>classificationModel <span class="op">=</span> pipeline.fit(trainingData)</span>
<span id="cb10-94"><a href="#cb10-94"></a><span class="co">## Now, the classification model can be used to predict the class label</span></span>
<span id="cb10-95"><a href="#cb10-95"></a><span class="co">## of new unlabeled data</span></span>
<span id="cb10-96"><a href="#cb10-96"></a></span>
<span id="cb10-97"><a href="#cb10-97"></a><span class="co">## *************************</span></span>
<span id="cb10-98"><a href="#cb10-98"></a><span class="co">## Prediction step</span></span>
<span id="cb10-99"><a href="#cb10-99"></a><span class="co">## *************************</span></span>
<span id="cb10-100"><a href="#cb10-100"></a><span class="co">## Read unlabeled data</span></span>
<span id="cb10-101"><a href="#cb10-101"></a><span class="co">## Create a DataFrame from unlabeledData.csv</span></span>
<span id="cb10-102"><a href="#cb10-102"></a><span class="co">## Unlabeled data in raw format</span></span>
<span id="cb10-103"><a href="#cb10-103"></a>unlabeledData <span class="op">=</span> spark.read.load(</span>
<span id="cb10-104"><a href="#cb10-104"></a>    unlabeledData,</span>
<span id="cb10-105"><a href="#cb10-105"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb10-106"><a href="#cb10-106"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb10-107"><a href="#cb10-107"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb10-108"><a href="#cb10-108"></a>)</span>
<span id="cb10-109"><a href="#cb10-109"></a></span>
<span id="cb10-110"><a href="#cb10-110"></a><span class="co">## Make predictions on unlabeled documents by using the</span></span>
<span id="cb10-111"><a href="#cb10-111"></a><span class="co">## Transformer.transform() method.</span></span>
<span id="cb10-112"><a href="#cb10-112"></a><span class="co">## The transform will only use the 'features' columns</span></span>
<span id="cb10-113"><a href="#cb10-113"></a>predictionsDF <span class="op">=</span> classificationModel.transform(unlabeledData)</span>
<span id="cb10-114"><a href="#cb10-114"></a></span>
<span id="cb10-115"><a href="#cb10-115"></a><span class="co">## The returned DataFrame has the following schema (attributes)</span></span>
<span id="cb10-116"><a href="#cb10-116"></a><span class="co">## |-- label: string (nullable = true)</span></span>
<span id="cb10-117"><a href="#cb10-117"></a><span class="co">## |-- text: string (nullable = true)</span></span>
<span id="cb10-118"><a href="#cb10-118"></a><span class="co">## |-- words: array (nullable = true)</span></span>
<span id="cb10-119"><a href="#cb10-119"></a><span class="co">## | |-- element: string (containsNull = true)</span></span>
<span id="cb10-120"><a href="#cb10-120"></a><span class="co">## |-- filteredWords: array (nullable = true)</span></span>
<span id="cb10-121"><a href="#cb10-121"></a><span class="co">## | |-- element: string (containsNull = true)</span></span>
<span id="cb10-122"><a href="#cb10-122"></a><span class="co">## |-- rawFeatures: vector (nullable = true)</span></span>
<span id="cb10-123"><a href="#cb10-123"></a><span class="co">## |-- features: vector (nullable = true)</span></span>
<span id="cb10-124"><a href="#cb10-124"></a><span class="co">## |-- rawPrediction: vector (nullable = true)</span></span>
<span id="cb10-125"><a href="#cb10-125"></a><span class="co">## |-- probability: vector (nullable = true)</span></span>
<span id="cb10-126"><a href="#cb10-126"></a><span class="co">## |-- prediction: double (nullable = false)</span></span>
<span id="cb10-127"><a href="#cb10-127"></a></span>
<span id="cb10-128"><a href="#cb10-128"></a><span class="co">## Select only the original features (i.e., the value of the original text attribute) and</span></span>
<span id="cb10-129"><a href="#cb10-129"></a><span class="co">## the predicted class for each record</span></span>
<span id="cb10-130"><a href="#cb10-130"></a>predictions <span class="op">=</span> predictionsDF.select(<span class="st">"text"</span>, <span class="st">"prediction"</span>)</span>
<span id="cb10-131"><a href="#cb10-131"></a></span>
<span id="cb10-132"><a href="#cb10-132"></a><span class="co">## Save the result in an HDFS output folder</span></span>
<span id="cb10-133"><a href="#cb10-133"></a>predictions.write.csv(outputPath, header<span class="op">=</span><span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
<section id="performance-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="performance-evaluation">Performance evaluation</h3>
<p>In order to test the goodness of algorithms there are some evaluators. The Evaluator can be</p>
<ul>
<li>a <code>BinaryClassificationEvaluator</code> for binary data</li>
<li>a <code>MulticlassClassificationEvaluator</code> for multiclass problems</li>
</ul>
<p>Provided metrics are:</p>
<ul>
<li>Accuracy</li>
<li>Precision</li>
<li>Recall</li>
<li>F-measure</li>
</ul>
<p>Use the <code>MulticlassClassificationEvaluator</code> estimator from <code>pyspark.ml.evaluator</code> on a DataFrame. The instantiated estimator has the method <code>.evaluate()</code> that is applied on a DataFrame: it compares the predictions with the true label values, and the output is the double value of the computed performance metric.</p>
<p>The parameters of <code>MulticlassClassificationEvaluator</code> are</p>
<ul>
<li><code>metricName</code>: type of metric to compute. It can assume the following values
<ul>
<li><code>"accuracy"</code></li>
<li><code>"f1"</code></li>
<li><code>"weightedPrecision"</code></li>
<li><code>"weightedRecall"</code></li>
</ul></li>
<li><code>labelCol</code>: input column with the true label/class value</li>
<li><code>predictionCol</code>: input column with the predicted class/label value</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In this example, the set of labeled data is read from a text file that contains one record/data point per line, and the records/data points are structured data with a fixed number of attributes (four)</p>
<ul>
<li>One attribute is the class label (“label”);</li>
<li>The other three attributes (“attr1”, “attr2”, “attr3”) are the predictive attributes that are used to predict the value of the class label.</li>
</ul>
<p>All attributes are already double attributes, and the input file has the header line.</p>
<p>Consider the following example input labeled data file</p>
<pre><code>label,attr1,attr2,attr3
1,0.0,1.1,0.1
0,2.0,1.0,-1.0
0,2.0,1.3,1.0
1,0.0,1.2,-0.5</code></pre>
<p>Follow these steps</p>
<ol type="1">
<li>Split the labeled data set in two subsets
<ul>
<li>Training set: <span class="math inline">\(75\%\)</span> of the labeled data</li>
<li>Test set: <span class="math inline">\(25\%\)</span> of the labeled data</li>
</ul></li>
<li>Infer/train a logistic regression model on the training set</li>
<li>Evaluate the prediction quality of the inferred model on both the test set and the training set</li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> LogisticRegression</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="im">from</span> pyspark.ml.evaluation <span class="im">import</span> MulticlassClassificationEvaluator</span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> Pipeline</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> PipelineModel</span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co">## input and output folders</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>labeledData <span class="op">=</span> <span class="st">"ex_dataValidation/labeledData.csv"</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>outputPath <span class="op">=</span> <span class="st">"predictionsLRPipelineValidation/"</span></span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="co">## Create a DataFrame from labeledData.csv</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="co">## Training data in raw format</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>labeledDataDF <span class="op">=</span> spark.read.load(</span>
<span id="cb12-15"><a href="#cb12-15"></a>    labeledData,</span>
<span id="cb12-16"><a href="#cb12-16"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb12-17"><a href="#cb12-17"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb12-18"><a href="#cb12-18"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>)</span>
<span id="cb12-20"><a href="#cb12-20"></a></span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="co">## Split labeled data in training and test set</span></span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="co">## training data : 75%</span></span>
<span id="cb12-23"><a href="#cb12-23"></a><span class="co">## test data: 25%</span></span>
<span id="cb12-24"><a href="#cb12-24"></a><span class="co">#trainDF, testDF = labeledDataDF.randomSplit([0.75, 0.25], seed=10) # &lt;1&gt;</span></span>
<span id="cb12-25"><a href="#cb12-25"></a></span>
<span id="cb12-26"><a href="#cb12-26"></a><span class="co">## *************************</span></span>
<span id="cb12-27"><a href="#cb12-27"></a><span class="co">## Training step</span></span>
<span id="cb12-28"><a href="#cb12-28"></a><span class="co">## *************************</span></span>
<span id="cb12-29"><a href="#cb12-29"></a><span class="co">## Define an assembler to create a column (features) of type Vector</span></span>
<span id="cb12-30"><a href="#cb12-30"></a><span class="co">## containing the double values associated with columns attr1, attr2, attr3</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>assembler <span class="op">=</span> VectorAssembler(</span>
<span id="cb12-32"><a href="#cb12-32"></a>    inputCols<span class="op">=</span>[<span class="st">"attr1"</span>, <span class="st">"attr2"</span>, <span class="st">"attr3"</span>],</span>
<span id="cb12-33"><a href="#cb12-33"></a>    outputCol<span class="op">=</span><span class="st">"features"</span></span>
<span id="cb12-34"><a href="#cb12-34"></a>)</span>
<span id="cb12-35"><a href="#cb12-35"></a></span>
<span id="cb12-36"><a href="#cb12-36"></a><span class="co">## Create a LogisticRegression object.</span></span>
<span id="cb12-37"><a href="#cb12-37"></a><span class="co">## LogisticRegression is an Estimator that is used to</span></span>
<span id="cb12-38"><a href="#cb12-38"></a><span class="co">## create a classification model based on logistic regression.</span></span>
<span id="cb12-39"><a href="#cb12-39"></a>lr <span class="op">=</span> LogisticRegression()</span>
<span id="cb12-40"><a href="#cb12-40"></a></span>
<span id="cb12-41"><a href="#cb12-41"></a><span class="co">## Set the values of the parameters of the</span></span>
<span id="cb12-42"><a href="#cb12-42"></a><span class="co">## Logistic Regression algorithm using the setter methods.</span></span>
<span id="cb12-43"><a href="#cb12-43"></a><span class="co">## There is one set method for each parameter</span></span>
<span id="cb12-44"><a href="#cb12-44"></a><span class="co">## For example, we are setting the number of maximum iterations to 10</span></span>
<span id="cb12-45"><a href="#cb12-45"></a><span class="co">## and the regularization parameter to 0.01</span></span>
<span id="cb12-46"><a href="#cb12-46"></a>lr.setMaxIter(<span class="dv">10</span>)</span>
<span id="cb12-47"><a href="#cb12-47"></a>lr.setRegParam(<span class="fl">0.01</span>)</span>
<span id="cb12-48"><a href="#cb12-48"></a></span>
<span id="cb12-49"><a href="#cb12-49"></a><span class="co">## Define a pipeline that is used to create the logistic regression</span></span>
<span id="cb12-50"><a href="#cb12-50"></a><span class="co">## model on the training data. The pipeline includes also</span></span>
<span id="cb12-51"><a href="#cb12-51"></a><span class="co">## the preprocessing step</span></span>
<span id="cb12-52"><a href="#cb12-52"></a>pipeline <span class="op">=</span> Pipeline().setStages([assembler, lr])</span>
<span id="cb12-53"><a href="#cb12-53"></a></span>
<span id="cb12-54"><a href="#cb12-54"></a><span class="co">## Execute the pipeline on the training data to build the</span></span>
<span id="cb12-55"><a href="#cb12-55"></a><span class="co">## classification model</span></span>
<span id="cb12-56"><a href="#cb12-56"></a>classificationModel <span class="op">=</span> pipeline.fit(trainDF)</span>
<span id="cb12-57"><a href="#cb12-57"></a><span class="co">## Now, the classification model can be used to predict the class label</span></span>
<span id="cb12-58"><a href="#cb12-58"></a><span class="co">## of new unlabeled data</span></span>
<span id="cb12-59"><a href="#cb12-59"></a></span>
<span id="cb12-60"><a href="#cb12-60"></a><span class="co">## Make predictions on the test data using the transform() method of the</span></span>
<span id="cb12-61"><a href="#cb12-61"></a><span class="co">## trained classification model transform uses only the content of 'features'</span></span>
<span id="cb12-62"><a href="#cb12-62"></a><span class="co">## to perform the predictions. The model is associated with the pipeline and hence</span></span>
<span id="cb12-63"><a href="#cb12-63"></a><span class="co">## also the assembler is executed</span></span>
<span id="cb12-64"><a href="#cb12-64"></a>predictionsDF <span class="op">=</span> classificationModel.transform(testDF)</span>
<span id="cb12-65"><a href="#cb12-65"></a></span>
<span id="cb12-66"><a href="#cb12-66"></a><span class="co">## The predicted value is column prediction</span></span>
<span id="cb12-67"><a href="#cb12-67"></a><span class="co">## The actual label is column label</span></span>
<span id="cb12-68"><a href="#cb12-68"></a><span class="co">## Define a set of evaluators</span></span>
<span id="cb12-69"><a href="#cb12-69"></a>myEvaluatorAcc <span class="op">=</span> MulticlassClassificationEvaluator(</span>
<span id="cb12-70"><a href="#cb12-70"></a>    labelCol<span class="op">=</span><span class="st">"label"</span>,</span>
<span id="cb12-71"><a href="#cb12-71"></a>    predictionCol<span class="op">=</span><span class="st">"prediction"</span>,</span>
<span id="cb12-72"><a href="#cb12-72"></a>    metricName<span class="op">=</span><span class="st">'accuracy'</span></span>
<span id="cb12-73"><a href="#cb12-73"></a>)</span>
<span id="cb12-74"><a href="#cb12-74"></a></span>
<span id="cb12-75"><a href="#cb12-75"></a>myEvaluatorF1 <span class="op">=</span> MulticlassClassificationEvaluator(</span>
<span id="cb12-76"><a href="#cb12-76"></a>    labelCol<span class="op">=</span><span class="st">"label"</span>,</span>
<span id="cb12-77"><a href="#cb12-77"></a>    predictionCol<span class="op">=</span><span class="st">"prediction"</span>,</span>
<span id="cb12-78"><a href="#cb12-78"></a>    metricName<span class="op">=</span><span class="st">'f1'</span></span>
<span id="cb12-79"><a href="#cb12-79"></a>)</span>
<span id="cb12-80"><a href="#cb12-80"></a></span>
<span id="cb12-81"><a href="#cb12-81"></a>myEvaluatorWeightedPrecision <span class="op">=</span> MulticlassClassificationEvaluator(</span>
<span id="cb12-82"><a href="#cb12-82"></a>    labelCol<span class="op">=</span><span class="st">"label"</span>,</span>
<span id="cb12-83"><a href="#cb12-83"></a>    predictionCol<span class="op">=</span><span class="st">"prediction"</span>,</span>
<span id="cb12-84"><a href="#cb12-84"></a>    metricName<span class="op">=</span><span class="st">'weightedPrecision'</span></span>
<span id="cb12-85"><a href="#cb12-85"></a>)</span>
<span id="cb12-86"><a href="#cb12-86"></a></span>
<span id="cb12-87"><a href="#cb12-87"></a>myEvaluatorWeightedRecall <span class="op">=</span> MulticlassClassificationEvaluator(</span>
<span id="cb12-88"><a href="#cb12-88"></a>    labelCol<span class="op">=</span><span class="st">"label"</span>,</span>
<span id="cb12-89"><a href="#cb12-89"></a>    predictionCol<span class="op">=</span><span class="st">"prediction"</span>,</span>
<span id="cb12-90"><a href="#cb12-90"></a>    metricName<span class="op">=</span><span class="st">'weightedRecall'</span></span>
<span id="cb12-91"><a href="#cb12-91"></a>)</span>
<span id="cb12-92"><a href="#cb12-92"></a></span>
<span id="cb12-93"><a href="#cb12-93"></a><span class="co">## Apply the evaluators on the predictions associated with the test data</span></span>
<span id="cb12-94"><a href="#cb12-94"></a><span class="co">## Print the results on the standard output</span></span>
<span id="cb12-95"><a href="#cb12-95"></a><span class="bu">print</span>(</span>
<span id="cb12-96"><a href="#cb12-96"></a>    <span class="st">"Accuracy on test data "</span>, </span>
<span id="cb12-97"><a href="#cb12-97"></a>    myEvaluatorAcc.evaluate(predictionsDF)</span>
<span id="cb12-98"><a href="#cb12-98"></a>)</span>
<span id="cb12-99"><a href="#cb12-99"></a></span>
<span id="cb12-100"><a href="#cb12-100"></a><span class="bu">print</span>(</span>
<span id="cb12-101"><a href="#cb12-101"></a>    <span class="st">"F1 on test data "</span>, </span>
<span id="cb12-102"><a href="#cb12-102"></a>    myEvaluatorF1.evaluate(predictionsDF)</span>
<span id="cb12-103"><a href="#cb12-103"></a>)</span>
<span id="cb12-104"><a href="#cb12-104"></a></span>
<span id="cb12-105"><a href="#cb12-105"></a><span class="bu">print</span>(</span>
<span id="cb12-106"><a href="#cb12-106"></a>    <span class="st">"Weighted recall on test data "</span>,</span>
<span id="cb12-107"><a href="#cb12-107"></a>    myEvaluatorWeightedRecall.evaluate(predictionsDF)</span>
<span id="cb12-108"><a href="#cb12-108"></a>)</span>
<span id="cb12-109"><a href="#cb12-109"></a></span>
<span id="cb12-110"><a href="#cb12-110"></a><span class="bu">print</span>(</span>
<span id="cb12-111"><a href="#cb12-111"></a>    <span class="st">"Weighted precision on test data "</span>,</span>
<span id="cb12-112"><a href="#cb12-112"></a>    myEvaluatorWeightedPrecision.evaluate(predictionsDF)</span>
<span id="cb12-113"><a href="#cb12-113"></a>)</span>
<span id="cb12-114"><a href="#cb12-114"></a></span>
<span id="cb12-115"><a href="#cb12-115"></a><span class="co">## Compute the prediction quality also for the training data.</span></span>
<span id="cb12-116"><a href="#cb12-116"></a><span class="co">## To check if the model is overfitted on the training data</span></span>
<span id="cb12-117"><a href="#cb12-117"></a></span>
<span id="cb12-118"><a href="#cb12-118"></a><span class="co">## Make predictions on the training data using the transform() method of the</span></span>
<span id="cb12-119"><a href="#cb12-119"></a><span class="co">## trained classification model transform uses only the content of 'features'</span></span>
<span id="cb12-120"><a href="#cb12-120"></a><span class="co">## to perform the predictions. The model is associated with the pipeline and hence</span></span>
<span id="cb12-121"><a href="#cb12-121"></a><span class="co">## also the assembler is executed</span></span>
<span id="cb12-122"><a href="#cb12-122"></a>predictionsTrainingDF <span class="op">=</span> classificationModel.transform(trainDF)</span>
<span id="cb12-123"><a href="#cb12-123"></a></span>
<span id="cb12-124"><a href="#cb12-124"></a><span class="co">## Apply the evaluators on the predictions associated with the test data</span></span>
<span id="cb12-125"><a href="#cb12-125"></a><span class="co">## Print the results on the standard output</span></span>
<span id="cb12-126"><a href="#cb12-126"></a></span>
<span id="cb12-127"><a href="#cb12-127"></a><span class="bu">print</span>(</span>
<span id="cb12-128"><a href="#cb12-128"></a>    <span class="st">"Accuracy on training data "</span>,</span>
<span id="cb12-129"><a href="#cb12-129"></a>    myEvaluatorAcc.evaluate(predictionsTrainingDF)</span>
<span id="cb12-130"><a href="#cb12-130"></a>)</span>
<span id="cb12-131"><a href="#cb12-131"></a></span>
<span id="cb12-132"><a href="#cb12-132"></a><span class="bu">print</span>(</span>
<span id="cb12-133"><a href="#cb12-133"></a>    <span class="st">"F1 on training data "</span>,</span>
<span id="cb12-134"><a href="#cb12-134"></a>    myEvaluatorF1.evaluate(predictionsTrainingDF)</span>
<span id="cb12-135"><a href="#cb12-135"></a>)</span>
<span id="cb12-136"><a href="#cb12-136"></a></span>
<span id="cb12-137"><a href="#cb12-137"></a><span class="bu">print</span>(</span>
<span id="cb12-138"><a href="#cb12-138"></a>    <span class="st">"Weighted recall on training data "</span>,</span>
<span id="cb12-139"><a href="#cb12-139"></a>    myEvaluatorWeightedRecall.evaluate(predictionsTrainingDF)</span>
<span id="cb12-140"><a href="#cb12-140"></a>)</span>
<span id="cb12-141"><a href="#cb12-141"></a></span>
<span id="cb12-142"><a href="#cb12-142"></a><span class="bu">print</span>(</span>
<span id="cb12-143"><a href="#cb12-143"></a>    <span class="st">"Weighted precision on training data "</span>,</span>
<span id="cb12-144"><a href="#cb12-144"></a>    myEvaluatorWeightedPrecision.evaluate(predictionsTrainingDF)</span>
<span id="cb12-145"><a href="#cb12-145"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>randomSplit</code> can be used to split the content of an input DataFrame in subsets</li>
</ol>
</div>
</div>
</div>
</section>
<section id="hyperparameter-tuning" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameter-tuning">Hyperparameter tuning</h3>
<p>The setting of the parameters of an algorithm is always a difficult task. A brute force approach can be used to find the setting optimizing a quality index, by splitting the training data in two subsets:</p>
<ul>
<li>The first set is used to build a model</li>
<li>The second one is used to evaluate the quality of the model</li>
</ul>
<p>The setting that maximizes a quality index (e.g., the prediction accuracy) is used to build the final model on the whole training dataset.</p>
<p>Using one single split of the training set usually leads to biased results, so the cross-validation approach is normally used</p>
<ul>
<li>Create <span class="math inline">\(k\)</span> splits and <span class="math inline">\(k\)</span> models</li>
<li>The parameter setting that achieves, on the average, the best result on the <span class="math inline">\(k\)</span> models is selected as final setting of the algorithm parameters</li>
</ul>
<p>Spark supports a brute-force grid-based approach to evaluate a set of possible parameter settings on a pipeline</p>
<ul>
<li>Input
<ul>
<li>An MLlib pipeline</li>
<li>A set of values to be evaluated for each input parameter of the pipeline: all the possible combinations of the specified parameter values are considered and the related models are automatically generated and evaluated by Spark</li>
<li>A quality evaluation metric to evaluate the result of the input pipeline</li>
</ul></li>
<li>Output: the model associated with the best parameter setting, in term of quality evaluation metric</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>This example shows how a grid-based approach can be used to tune a logistic regression classifier on a structured dataset: the pipeline that is repeated multiple times is based on the cross validation component. The input data set is the same structured dataset used for the example of the evaluators.</p>
<p>The following parameters of the logistic regression algorithm are considered in the brute-force search/parameter tuning</p>
<ul>
<li>Maximum iteration: <span class="math inline">\([10, 100, 1000]\)</span></li>
<li>Regulation parameter: <span class="math inline">\([0.1, 0.01]\)</span></li>
</ul>
<p>In total, 6 parameter configurations are evaluated (<span class="math inline">\(3*2\)</span>).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="im">from</span> pyspark.mllib.linalg <span class="im">import</span> Vectors</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="im">from</span> pyspark.ml.feature <span class="im">import</span> VectorAssembler</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="im">from</span> pyspark.ml.classification <span class="im">import</span> LogisticRegression</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="im">from</span> pyspark.ml.evaluation <span class="im">import</span> MulticlassClassificationEvaluator</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="im">from</span> pyspark.ml.evaluation <span class="im">import</span> BinaryClassificationEvaluator</span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="im">from</span> pyspark.ml.tuning <span class="im">import</span> ParamGridBuilder</span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="im">from</span> pyspark.ml.tuning <span class="im">import</span> CrossValidator</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> Pipeline</span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="im">from</span> pyspark.ml <span class="im">import</span> PipelineModel</span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="co">## input and output folders</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>labeledData <span class="op">=</span> <span class="st">"ex_dataValidation/labeledData.csv"</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>unlabeledData <span class="op">=</span> <span class="st">"ex_dataValidation/unlabeledData.csv"</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>outputPath <span class="op">=</span> <span class="st">"predictionsLRPipelineTuning/"</span></span>
<span id="cb13-15"><a href="#cb13-15"></a></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="co">## Create a DataFrame from labeledData.csv</span></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="co">## Training data in raw format</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>labeledDataDF <span class="op">=</span> spark.read.load(</span>
<span id="cb13-19"><a href="#cb13-19"></a>    labeledData,</span>
<span id="cb13-20"><a href="#cb13-20"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb13-21"><a href="#cb13-21"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb13-22"><a href="#cb13-22"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb13-23"><a href="#cb13-23"></a>)</span>
<span id="cb13-24"><a href="#cb13-24"></a></span>
<span id="cb13-25"><a href="#cb13-25"></a><span class="co">## *************************</span></span>
<span id="cb13-26"><a href="#cb13-26"></a><span class="co">## Training step</span></span>
<span id="cb13-27"><a href="#cb13-27"></a><span class="co">## *************************</span></span>
<span id="cb13-28"><a href="#cb13-28"></a><span class="co">## Define an assembler to create a column (features) of type Vector</span></span>
<span id="cb13-29"><a href="#cb13-29"></a><span class="co">## containing the double values associated with columns attr1, attr2, attr3</span></span>
<span id="cb13-30"><a href="#cb13-30"></a>assembler <span class="op">=</span> VectorAssembler(</span>
<span id="cb13-31"><a href="#cb13-31"></a>    inputCols<span class="op">=</span>[<span class="st">"attr1"</span>, <span class="st">"attr2"</span>, <span class="st">"attr3"</span>],</span>
<span id="cb13-32"><a href="#cb13-32"></a>    outputCol<span class="op">=</span><span class="st">"features"</span></span>
<span id="cb13-33"><a href="#cb13-33"></a>)</span>
<span id="cb13-34"><a href="#cb13-34"></a></span>
<span id="cb13-35"><a href="#cb13-35"></a><span class="co">## Create a LogisticRegression object.</span></span>
<span id="cb13-36"><a href="#cb13-36"></a><span class="co">## LogisticRegression is an Estimator that is used to</span></span>
<span id="cb13-37"><a href="#cb13-37"></a><span class="co">## create a classification model based on logistic regression.</span></span>
<span id="cb13-38"><a href="#cb13-38"></a>lr <span class="op">=</span> LogisticRegression()</span>
<span id="cb13-39"><a href="#cb13-39"></a></span>
<span id="cb13-40"><a href="#cb13-40"></a><span class="co">## Define a pipeline that is used to create the logistic regression</span></span>
<span id="cb13-41"><a href="#cb13-41"></a><span class="co">## model on the training data. The pipeline includes also the preprocessing step</span></span>
<span id="cb13-42"><a href="#cb13-42"></a>pipeline <span class="op">=</span> Pipeline().setStages([assembler, lr])</span>
<span id="cb13-43"><a href="#cb13-43"></a></span>
<span id="cb13-44"><a href="#cb13-44"></a><span class="co">## We use a ParamGridBuilder to construct a grid of parameter values to</span></span>
<span id="cb13-45"><a href="#cb13-45"></a><span class="co">## search over.</span></span>
<span id="cb13-46"><a href="#cb13-46"></a><span class="co">## We set 3 values for lr.setMaxIter and 2 values for lr.regParam.</span></span>
<span id="cb13-47"><a href="#cb13-47"></a><span class="co">## This grid will evaluate 3 x 2 = 6 parameter settings for</span></span>
<span id="cb13-48"><a href="#cb13-48"></a><span class="co">## the input pipeline.</span></span>
<span id="cb13-49"><a href="#cb13-49"></a>paramGrid <span class="op">=</span> ParamGridBuilder() <span class="op">\</span></span>
<span id="cb13-50"><a href="#cb13-50"></a>    .addGrid(lr.maxIter, [<span class="dv">10</span>,<span class="dv">100</span>,<span class="dv">1000</span>]) <span class="op">\</span></span>
<span id="cb13-51"><a href="#cb13-51"></a>    .addGrid(lr.regParam, [<span class="fl">0.1</span>,<span class="fl">0.01</span>]) <span class="op">\</span></span>
<span id="cb13-52"><a href="#cb13-52"></a>    <span class="co">#.build() # &lt;1&gt;</span></span>
<span id="cb13-53"><a href="#cb13-53"></a></span>
<span id="cb13-54"><a href="#cb13-54"></a><span class="co">## We now treat the Pipeline as an Estimator, wrapping it in a</span></span>
<span id="cb13-55"><a href="#cb13-55"></a><span class="co">## CrossValidator instance. This allows us to jointly choose parameters</span></span>
<span id="cb13-56"><a href="#cb13-56"></a><span class="co">## for all Pipeline stages.</span></span>
<span id="cb13-57"><a href="#cb13-57"></a><span class="co">## CrossValidator requires</span></span>
<span id="cb13-58"><a href="#cb13-58"></a><span class="co">## - an Estimator</span></span>
<span id="cb13-59"><a href="#cb13-59"></a><span class="co">## - a set of Estimator ParamMaps</span></span>
<span id="cb13-60"><a href="#cb13-60"></a><span class="co">## - an Evaluator.</span></span>
<span id="cb13-61"><a href="#cb13-61"></a>cv <span class="op">=</span> CrossValidator() <span class="op">\</span></span>
<span id="cb13-62"><a href="#cb13-62"></a>    .setEstimator(pipeline) <span class="op">\</span></span>
<span id="cb13-63"><a href="#cb13-63"></a>    .setEstimatorParamMaps(paramGrid) <span class="op">\</span></span>
<span id="cb13-64"><a href="#cb13-64"></a>    .setEvaluator(BinaryClassificationEvaluator()) <span class="op">\</span></span>
<span id="cb13-65"><a href="#cb13-65"></a>    <span class="co">#.setNumFolds(3) # &lt;2&gt;</span></span>
<span id="cb13-66"><a href="#cb13-66"></a></span>
<span id="cb13-67"><a href="#cb13-67"></a><span class="co">## Run cross-validation. The result is the logistic regression model</span></span>
<span id="cb13-68"><a href="#cb13-68"></a><span class="co">## based on the best set of parameters (based on the results of the</span></span>
<span id="cb13-69"><a href="#cb13-69"></a><span class="co">## cross-validation operation).</span></span>
<span id="cb13-70"><a href="#cb13-70"></a><span class="co">#tunedLRmodel = cv.fit(labeledDataDF) # &lt;3&gt;</span></span>
<span id="cb13-71"><a href="#cb13-71"></a></span>
<span id="cb13-72"><a href="#cb13-72"></a><span class="co">## Now, the tuned classification model can be used to predict the class label</span></span>
<span id="cb13-73"><a href="#cb13-73"></a><span class="co">## of new unlabeled data</span></span>
<span id="cb13-74"><a href="#cb13-74"></a></span>
<span id="cb13-75"><a href="#cb13-75"></a><span class="co">## *************************</span></span>
<span id="cb13-76"><a href="#cb13-76"></a><span class="co">## Prediction step</span></span>
<span id="cb13-77"><a href="#cb13-77"></a><span class="co">## *************************</span></span>
<span id="cb13-78"><a href="#cb13-78"></a><span class="co">## Create a DataFrame from unlabeledData.csv</span></span>
<span id="cb13-79"><a href="#cb13-79"></a><span class="co">## Unlabeled data in raw format</span></span>
<span id="cb13-80"><a href="#cb13-80"></a>unlabeledData <span class="op">=</span> spark.read.load(</span>
<span id="cb13-81"><a href="#cb13-81"></a>    unlabeledData,</span>
<span id="cb13-82"><a href="#cb13-82"></a>    <span class="bu">format</span><span class="op">=</span><span class="st">"csv"</span>,</span>
<span id="cb13-83"><a href="#cb13-83"></a>    header<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb13-84"><a href="#cb13-84"></a>    inferSchema<span class="op">=</span><span class="va">True</span></span>
<span id="cb13-85"><a href="#cb13-85"></a>)</span>
<span id="cb13-86"><a href="#cb13-86"></a></span>
<span id="cb13-87"><a href="#cb13-87"></a><span class="co">## Make predictions on the unlabled data using the transform() method of the</span></span>
<span id="cb13-88"><a href="#cb13-88"></a><span class="co">## trained tuned classification model transform uses only the content of 'features'</span></span>
<span id="cb13-89"><a href="#cb13-89"></a><span class="co">## to perform the predictions. The model is associated with the pipeline and hence</span></span>
<span id="cb13-90"><a href="#cb13-90"></a><span class="co">## also the assembler is executed</span></span>
<span id="cb13-91"><a href="#cb13-91"></a>predictionsDF <span class="op">=</span> tunedLRmodel.transform(unlabeledData)</span>
<span id="cb13-92"><a href="#cb13-92"></a></span>
<span id="cb13-93"><a href="#cb13-93"></a><span class="co">## The returned DataFrame has the following schema (attributes)</span></span>
<span id="cb13-94"><a href="#cb13-94"></a><span class="co">## - features: vector (values of the attributes)</span></span>
<span id="cb13-95"><a href="#cb13-95"></a><span class="co">## - label: double (value of the class label)</span></span>
<span id="cb13-96"><a href="#cb13-96"></a><span class="co">## - rawPrediction: vector (nullable = true)</span></span>
<span id="cb13-97"><a href="#cb13-97"></a><span class="co">## - probability: vector (The i-th cell contains the probability that the current</span></span>
<span id="cb13-98"><a href="#cb13-98"></a><span class="co">## record belongs to the i-th class</span></span>
<span id="cb13-99"><a href="#cb13-99"></a><span class="co">## - prediction: double (the predicted class label)</span></span>
<span id="cb13-100"><a href="#cb13-100"></a><span class="co">## Select only the original features (i.e., the value of the original attributes</span></span>
<span id="cb13-101"><a href="#cb13-101"></a><span class="co">## attr1, attr2, attr3) and the predicted class for each record</span></span>
<span id="cb13-102"><a href="#cb13-102"></a>predictions <span class="op">=</span> predictionsDF.select(<span class="st">"attr1"</span>, <span class="st">"attr2"</span>, <span class="st">"attr3"</span>, <span class="st">"prediction"</span>)</span>
<span id="cb13-103"><a href="#cb13-103"></a></span>
<span id="cb13-104"><a href="#cb13-104"></a><span class="co">## Save the result in an HDFS output folder</span></span>
<span id="cb13-105"><a href="#cb13-105"></a>predictions.write.csv(outputPath, header<span class="op">=</span><span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>There is one call to the addGrid method for each parameter that we want to set: each call to the addGrid method is characterized by the parameter we want to consider, and the list of values to test/to consider.</li>
<li>Here the characteristics of the cross validation are set: the pipeline to be evaluated, the set of parameters to be considered, the evaluator (i.e., the object that is used to evaluate the quality of the model), and the number of folds to consider (i.e., the number of repetitions).</li>
<li>The returned model is the one associated with the best parameter setting, based on the result of the cross-validation test</li>
</ol>
</div>
</div>
</div>
</section>
<section id="sparse-labeled-data" class="level3">
<h3 class="anchored" data-anchor-id="sparse-labeled-data">Sparse labeled data</h3>
<p>Frequently the training data are sparse (e.g., textual data are sparse: each document contains only a subset of the possible words), so sparse vectors are frequently used. MLlib supports reading training examples stored in the LIBSVM format: this is a commonly used textual format that is used to represent sparse documents/data points.</p>
<p>The LIBSVM format is a textual format in which each line represents an input record/data point by using a sparse feature vector: each line has the format</p>
<pre><code>label index1:value1 index2:value2 ...</code></pre>
<p>where</p>
<ul>
<li><code>label</code> is an integer associated with the class label. It is the first value of each line.</li>
<li><code>index#</code> are integer values representing the features</li>
<li><code>value#</code> are the (double) values of the features</li>
</ul>
<p>Consider the following two records/data points characterized by 4 predictive features and a class label</p>
<table class="table">
<tbody>
<tr class="odd">
<td><span class="math inline">\(\textbf{Features} = [5.8, 1.7, 0 , 0 ]\)</span></td>
<td><span class="math inline">\(\textbf{Label} = 1\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\textbf{Features} = [4.1, 0 , 2.5, 1.2]\)</span></td>
<td><span class="math inline">\(\textbf{Label} = 0\)</span></td>
</tr>
</tbody>
</table>
<p>Their LIBSVM format-based representation is the following</p>
<pre><code>1 1:5.8 2:1.7
0 1:4.1 3:2.5 4:1.2</code></pre>
<p>LIBSVM files can be loaded into DataFrames by combining the following methods</p>
<ul>
<li><code>read()</code></li>
<li><code>format("libsvm")</code></li>
<li><code>load(inputpath)</code></li>
</ul>
<p>The returned DataFrame has two columns:</p>
<ul>
<li>label: the double value associated with the label</li>
<li>features: the sparse vector associated with the predictive features</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>spark.read.<span class="bu">format</span>(<span class="st">"libsvm"</span>).load(<span class="st">"sample_libsvm_data.txt"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./18a_spark_mllib.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./18c_clustering.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Clustering algorithms</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>