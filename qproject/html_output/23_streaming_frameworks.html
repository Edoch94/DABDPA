<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Distributed architectures for big data processing and analytics - 28&nbsp; Streaming data analytics frameworks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./22_structured_streaming.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./23_streaming_frameworks.html"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Distributed architectures for big data processing and analytics</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">About this Book</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_01_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Big data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Big data architectures</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03b_HDFS_clc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">HDFS and Hadoop: command line commands</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_intro_hadoop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Hadoop and MapReduce</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_hadoop_implementation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">How to write MapReduce programs in Hadoop</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_mapreduce_patterns_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">MapReduce patterns - 1</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_mapreduce_advanced_topics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">MapReduce and Hadoop Advanced Topics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_mapreduce_patterns_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">MapReduce patterns - 2</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_sql_operators_mapreduce.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Relational Algebra Operations and MapReduce</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b_spark_submit_execute.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">How to submit/execute a Spark application</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_intro_spark.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Spark</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_rdd_based_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">RDD based programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_rdd_keyvalue_pairs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">RDDs and key-value pairs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13_rdd_numbers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">RDD of numbers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14_cache_accumulators_broadcast.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Cache, Accumulators, Broadcast Variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15b_pagerank.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introduction to PageRank</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16_sparksql_dataframes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Spark SQL and DataFrames</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18a_spark_mllib.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18b_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18c_clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Clustering algorithms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18d_regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Regression algorithms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18e_mining.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Itemset and Association rule mining</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19_graph_analytics_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Graph analytics in Spark</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_graph_analytics_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Graph Analytics in Spark</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21_streaming_analytics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22_structured_streaming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23_streaming_frameworks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#stream-processing-frameworks-for-big-streaming-data-analytics" id="toc-stream-processing-frameworks-for-big-streaming-data-analytics" class="nav-link active" data-scroll-target="#stream-processing-frameworks-for-big-streaming-data-analytics">Stream processing frameworks for (big) streaming data analytics</a></li>
  <li><a href="#introduction-to-apache-storm" id="toc-introduction-to-apache-storm" class="nav-link" data-scroll-target="#introduction-to-apache-storm">Introduction to Apache Storm</a></li>
  <li><a href="#storm-core-concepts" id="toc-storm-core-concepts" class="nav-link" data-scroll-target="#storm-core-concepts">Storm core concepts</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="stream-processing-frameworks-for-big-streaming-data-analytics" class="level3">
<h3 class="anchored" data-anchor-id="stream-processing-frameworks-for-big-streaming-data-analytics">Stream processing frameworks for (big) streaming data analytics</h3>
<p>Several frameworks have been proposed to process in real-time or in near real-time data streams:</p>
<ul>
<li>Apache Spark (Streaming component)</li>
<li>Apache Storm</li>
<li>Apache Flink</li>
<li>Apache Samza</li>
<li>Apache Apex</li>
<li>Apache Flume</li>
<li>Amazon Kinesis Streams</li>
<li>…</li>
</ul>
<p>All these frameworks use a cluster of servers to scale horizontally with respect to the (big) amount of data to be analyzed.</p>
<section id="comparison-among-state-of-the-art-streaming-frameworks" class="level4">
<h4 class="anchored" data-anchor-id="comparison-among-state-of-the-art-streaming-frameworks">Comparison among state of the art streaming frameworks</h4>
<p><strong>Apache Spark Streaming</strong></p>
<ul>
<li>Micro-batch applications</li>
<li>Processes each record exactly once</li>
</ul>
<p><strong>Apache Storm</strong></p>
<ul>
<li>Continuous/real-time computation: very low latency</li>
<li>Processes each record at least once in real-time: each record could be processed multiple times, hence may update mutable state twice</li>
<li>Apache Storm Trident API: it is a running modality of Apache Storm that processes each record exactly once (micro-batch); slower than the Apache Storm version</li>
</ul>
<p><strong>Apache Flink</strong></p>
<ul>
<li>Continuous/real-time stateful computations over data streams: low latency</li>
<li>Processes each record exactly once</li>
</ul>
</section>
</section>
<section id="introduction-to-apache-storm" class="level3">
<h3 class="anchored" data-anchor-id="introduction-to-apache-storm">Introduction to Apache Storm</h3>
<p>Apache Storm™ is a distributed framework that is used for real-time processing of data streams (e.g., Tweets analysis, Log processing). Currently, it is an <a href="http://storm.apache.org/">open source project</a> of the Apache Software Foundation. It is implemented in Clojure and Java (12 core committers, plus about 70 contributors).</p>
<p>Storm was first developed by Nathan Marz at BackType, a company that provided social search applications. Later (2011), BackType was acquired by Twitter, and now it is a critical part of their infrastructure. Currently, Storm is a project of the Apache Software Foundation (since 2013).</p>
<section id="data-processing" class="level4">
<h4 class="anchored" data-anchor-id="data-processing">Data processing</h4>
<ul>
<li>Continuous computation: Storm can do continuous computation on data streams in real time; it can process each message as it comes (an example of continuous computation is streaming trending topics detection on Twitter)</li>
<li>Real-time analytics: Storm can analyze and extract insights or complex knowledge from data that come from several real-time data streams</li>
</ul>
</section>
<section id="features-of-storm" class="level4">
<h4 class="anchored" data-anchor-id="features-of-storm">Features of Storm</h4>
<p>Storm is</p>
<ul>
<li>Distributed: Storm is a distributed system than can run on a cluster of commodity servers.</li>
<li>Horizontally scalable: Storm allows adding more servers (nodes) to your Storm cluster and increase the processing capacity of your application. It is linearly scalable with respect to the number of nodes, which means that you can double the processing capacity by doubling the nodes.</li>
<li>Fast: Storm has been reported to process up to 1 million tuples per second per node.</li>
<li>Fault tolerant: Units of work are executed by worker processes in a Storm cluster. When a worker dies, Storm will restart that worker (on the same node or on to another node).</li>
<li>Reliable - Guaranteed data processing: Storm provides guarantees that each message (tuple) will be processed at least once; in case of failures, Storm will replay the lost tuples, and it can be configured to process each tuple only once.</li>
<li>Easy to operate: Storm is simple to deploy and manage. Once the cluster is deployed, it requires little maintenance.</li>
<li>Programming language agnostic: Even though the Storm platform runs on Java Virtual Machine, the applications that run over it can be written in any programming language that can read and write to standard input and output streams.</li>
</ul>
</section>
</section>
<section id="storm-core-concepts" class="level3">
<h3 class="anchored" data-anchor-id="storm-core-concepts">Storm core concepts</h3>
<p>Storm can be considered a distributed Function Programming-like processing of data streams. It applies a set of functions, in a specific order, on the elements of the input data streams and emits new data streams, however, each function can store its state by means of variables, and so it is not pure functional programming.</p>
<section id="main-concepts" class="level4">
<h4 class="anchored" data-anchor-id="main-concepts">Main concepts</h4>
<ul>
<li>Tuple</li>
<li>Data Stream</li>
<li>Spout</li>
<li>Bolt</li>
<li>Topology</li>
</ul>
</section>
<section id="data-model" class="level4">
<h4 class="anchored" data-anchor-id="data-model">Data model</h4>
<p>The basic unit of data that can be processed by a Storm application is called a tuple: each tuple is a predefined list of fields. The data type of each field can be common data types, (e.g., byte, char, string, integer), or your own data types, which can be serialized as fields in a tuple. Each field of a tuple has a name.</p>
<p>A tuple is dynamically typed, that is, you just need to define the names of the fields in a tuple and not their data type.</p>
<p>Storm processes streams of tuples. Each stream</p>
<ul>
<li>is an unbounded sequence of tuples</li>
<li>has a name</li>
<li>is composed of homogenous tuples (i.e., tuples with the same structure)</li>
</ul>
<p>However, each applications can process multiple, heterogonous, data streams.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Tuple</p>
<pre><code>(1.1.1.1,"foo.com")</code></pre>
<p>Stream of tuples</p>
<pre><code>(1.1.1.1,"foo.com")
(2.2.2.2,"bar.net")
(3.3.3.3,"foo.com")
...</code></pre>
</div>
</div>
</div>
</section>
<section id="spout" class="level4">
<h4 class="anchored" data-anchor-id="spout">Spout</h4>
<p>Spout is the component generating/handling the input data stream. Spouts read or listen to data from external sources and publish them (emit in Storm terminology) into streams.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Examples
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li>A spout can be used to connect to the Twitter API and emit a stream of tweets</li>
<li>A spout can be used to read a log file and emit a stream of composed of the its lines</li>
</ul>
</div>
</div>
</div>
<p>Each spout can emit multiple streams, with different schemas; for example, it is possible to implement a spout that reads 10-field records from a log file and emits them as two different streams of 7-tuples and 4-tuples, respectively.</p>
<p>Spouts can be</p>
<ul>
<li>unreliable (fire-and-forget)</li>
<li>reliable (can replay failed tuples)</li>
</ul>
</section>
<section id="bolt" class="level4">
<h4 class="anchored" data-anchor-id="bolt">Bolt</h4>
<p>Bolt is the component that is used to apply a function over each tuple of a stream. Bolts consume one or more streams, emitted by spouts or other bolts, and potentially produce new streams.</p>
<p>Bolts can be used to</p>
<ul>
<li>filter or transform the content of the input streams and emit new data streams that will be processed by other bolts</li>
<li>process the data streams and store/persist the result of the computation in some of “storage” (files, Databases, ..)</li>
</ul>
<p>Each bolt can emit multiple streams, with different schemas.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Examples
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li>A bolt can be used to extract one field from each tuple of its input stream</li>
<li>A bolt can be used to join two streams, based on a common field</li>
<li>A bolt can be used to count the occurrences of a set of URLs</li>
</ul>
</div>
</div>
</div>
<p>The input streams of a Storm cluster are handled by spouts</p>
<ul>
<li>Each spout passes the data streams to bolts, which transform them in some way</li>
<li>Each bolt either persists the data in some sort of storage or passes it to some other bolts</li>
</ul>
<p>A Storm program is a chain of bolts making some computations/transformations on the data exposed by spouts and bolts.</p>
</section>
<section id="topology" class="level4">
<h4 class="anchored" data-anchor-id="topology">Topology</h4>
<p>A Storm topology is an abstraction that defines the graph of the computation: it specifies which spouts and bolts are used and how they are connected. A topology can be represented by a direct acyclic graph (DAG), where each node does some kind of processing and eventually forwards it to the next node(s) in the flow (i.e., a topology in Storm wires data and functions via a DAG).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption class="figure-caption">Topology example</figcaption>
<p><img src="images/23_streaming_frameworks/topology_example.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption class="figure-caption">Functional programming</figcaption>
<p><img src="images/23_streaming_frameworks/functional_programming.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption class="figure-caption">Topology example</figcaption>
<p><img src="images/23_streaming_frameworks/topology_example_2.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<ul>
<li>Notice that there are two input data streams in this topology</li>
<li>There are also two output data streams</li>
</ul>
<section id="topology-execution" class="level5">
<h5 class="anchored" data-anchor-id="topology-execution">Topology execution</h5>
<p>The topology is executed on the servers of the cluster running Storm. The system automatically decides which parts of the topology are executed by each server of the cluster</p>
<ul>
<li>Each topology runs until its is explicitly killed</li>
<li>Each cluster can runs multiple topologies at the same time</li>
</ul>
<section id="worker-processes" class="level6">
<h6 class="anchored" data-anchor-id="worker-processes">Worker processes</h6>
<ul>
<li>Each node in the cluster can run one or more JVMs called worker processes that are responsible for processing a part of the topology.</li>
<li>Each topology executes across one or more worker processes</li>
<li>Each worker process is bound to one of the topologies and can execute multiple components (spouts and/or bolts) of that topology; hence, even if multiple topologies are run at the same time, none of them will share any of the workers</li>
</ul>
</section>
<section id="executor" class="level6">
<h6 class="anchored" data-anchor-id="executor">Executor</h6>
<ul>
<li>Within each worker process, there can be multiple threads that execute parts of the topology. Each of these threads is called an executor</li>
<li>An executor can execute only one of the components of the topology, that is, any one spout or bolt in the topology, but it may run one or more tasks for the same component</li>
<li>Each spout or bolt can be associated with many executors and hence executed in parallel</li>
</ul>
</section>
<section id="tasks" class="level6">
<h6 class="anchored" data-anchor-id="tasks">Tasks</h6>
<p>A task is the most granular unit of task execution in Storm: each task is an instance of a spout or bolt, and it performs the actual data processing</p>
<ul>
<li>Each spout or bolt that you implement in your code executes as many tasks across the cluster</li>
<li>Each task can be executed alone or with another task of the same type (in the same executor)</li>
</ul>
<p>The number of tasks for a component is always the same throughout the lifetime of a topology (it is set when the topology is submitted), but the number of executors (threads) for a component can change over time (i.e., it is possible to add/remove executors for each component).</p>
<p>The parallelism of the topology is given by the number of executors (i.e., number of threads). For each spout/bolt the application can specify</p>
<ul>
<li>The number of executors: this value can be changed at runtime</li>
<li>The number of tasks: this value is set before submitting the topology and cannot be change at runtime</li>
</ul>


<!-- -->

</section>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Handle positioning of the toggle
      window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./22_structured_streaming.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb3" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1"></a><span class="fu"># Streaming data analytics frameworks</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="fu">## Stream processing frameworks for (big) streaming data analytics</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>Several frameworks have been proposed to process in real-time or in near real-time data streams:</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ss">- </span>Apache Spark (Streaming component)</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="ss">- </span>Apache Storm</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="ss">- </span>Apache Flink</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="ss">- </span>Apache Samza</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="ss">- </span>Apache Apex</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="ss">- </span>Apache Flume</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="ss">- </span>Amazon Kinesis Streams</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="ss">- </span>...</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a>All these frameworks use a cluster of servers to scale horizontally with respect to the (big) amount of data to be analyzed.</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="fu">### Comparison among state of the art streaming frameworks</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>**Apache Spark Streaming**</span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="ss">- </span>Micro-batch applications</span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="ss">- </span>Processes each record exactly once</span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a>**Apache Storm**</span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="ss">- </span>Continuous/real-time computation: very low latency</span>
<span id="cb3-25"><a href="#cb3-25"></a><span class="ss">- </span>Processes each record at least once in real-time: each record could be processed multiple times, hence may update mutable state twice</span>
<span id="cb3-26"><a href="#cb3-26"></a><span class="ss">- </span>Apache Storm Trident API: it is a running modality of Apache Storm that processes each record exactly once (micro-batch); slower than the Apache Storm version</span>
<span id="cb3-27"><a href="#cb3-27"></a></span>
<span id="cb3-28"><a href="#cb3-28"></a>**Apache Flink**</span>
<span id="cb3-29"><a href="#cb3-29"></a></span>
<span id="cb3-30"><a href="#cb3-30"></a><span class="ss">- </span>Continuous/real-time stateful computations over data streams: low latency</span>
<span id="cb3-31"><a href="#cb3-31"></a><span class="ss">- </span>Processes each record exactly once</span>
<span id="cb3-32"><a href="#cb3-32"></a></span>
<span id="cb3-33"><a href="#cb3-33"></a><span class="fu">## Introduction to Apache Storm</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>Apache Storm™ is a distributed framework that is used for real-time processing of data streams (e.g., Tweets analysis, Log processing). Currently, it is an <span class="co">[</span><span class="ot">open source project</span><span class="co">](http://storm.apache.org/)</span> of the Apache Software Foundation. It is implemented in Clojure and Java (12 core committers, plus about 70 contributors).</span>
<span id="cb3-35"><a href="#cb3-35"></a></span>
<span id="cb3-36"><a href="#cb3-36"></a>Storm was first developed by Nathan Marz at BackType, a company that provided social search applications. Later (2011), BackType was acquired by Twitter, and now it is a critical part of their infrastructure. Currently, Storm is a project of the Apache Software Foundation (since 2013).</span>
<span id="cb3-37"><a href="#cb3-37"></a></span>
<span id="cb3-38"><a href="#cb3-38"></a><span class="fu">### Data processing</span></span>
<span id="cb3-39"><a href="#cb3-39"></a><span class="ss">- </span>Continuous computation: Storm can do continuous computation on data streams in real time; it can process each message as it comes (an example of continuous computation is streaming trending topics detection on Twitter)</span>
<span id="cb3-40"><a href="#cb3-40"></a><span class="ss">- </span>Real-time analytics: Storm can analyze and extract insights or complex knowledge from data that come from several real-time data streams</span>
<span id="cb3-41"><a href="#cb3-41"></a></span>
<span id="cb3-42"><a href="#cb3-42"></a><span class="fu">### Features of Storm</span></span>
<span id="cb3-43"><a href="#cb3-43"></a>Storm is</span>
<span id="cb3-44"><a href="#cb3-44"></a></span>
<span id="cb3-45"><a href="#cb3-45"></a><span class="ss">- </span>Distributed: Storm is a distributed system than can run on a cluster of commodity servers.</span>
<span id="cb3-46"><a href="#cb3-46"></a><span class="ss">- </span>Horizontally scalable: Storm allows adding more servers (nodes) to your Storm cluster and increase the processing capacity of your application. It is linearly scalable with respect to the number of nodes, which means that you can double the processing capacity by doubling the nodes.</span>
<span id="cb3-47"><a href="#cb3-47"></a><span class="ss">- </span>Fast: Storm has been reported to process up to 1 million tuples per second per node.</span>
<span id="cb3-48"><a href="#cb3-48"></a><span class="ss">- </span>Fault tolerant: Units of work are executed by worker processes in a Storm cluster. When a worker dies, Storm will restart that worker (on the same node or on to another node).</span>
<span id="cb3-49"><a href="#cb3-49"></a><span class="ss">- </span>Reliable - Guaranteed data processing: Storm provides guarantees that each message (tuple) will be processed at least once; in case of failures, Storm will replay the lost tuples, and it can be configured to process each tuple only once.</span>
<span id="cb3-50"><a href="#cb3-50"></a><span class="ss">- </span>Easy to operate: Storm is simple to deploy and manage. Once the cluster is deployed, it requires little maintenance.</span>
<span id="cb3-51"><a href="#cb3-51"></a><span class="ss">- </span>Programming language agnostic: Even though the Storm platform runs on Java Virtual Machine, the applications that run over it can be written in any programming language that can read and write to standard input and output streams.</span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a><span class="fu">## Storm core concepts</span></span>
<span id="cb3-54"><a href="#cb3-54"></a>Storm can be considered a distributed Function Programming-like processing of data streams. It applies a set of functions, in a specific order, on the elements of the input data streams and emits new data streams, however, each function can store its state by means of variables, and so it is not pure functional programming.</span>
<span id="cb3-55"><a href="#cb3-55"></a></span>
<span id="cb3-56"><a href="#cb3-56"></a><span class="fu">### Main concepts</span></span>
<span id="cb3-57"><a href="#cb3-57"></a><span class="ss">- </span>Tuple</span>
<span id="cb3-58"><a href="#cb3-58"></a><span class="ss">- </span>Data Stream</span>
<span id="cb3-59"><a href="#cb3-59"></a><span class="ss">- </span>Spout</span>
<span id="cb3-60"><a href="#cb3-60"></a><span class="ss">- </span>Bolt</span>
<span id="cb3-61"><a href="#cb3-61"></a><span class="ss">- </span>Topology</span>
<span id="cb3-62"><a href="#cb3-62"></a></span>
<span id="cb3-63"><a href="#cb3-63"></a><span class="fu">### Data model</span></span>
<span id="cb3-64"><a href="#cb3-64"></a>The basic unit of data that can be processed by a Storm application is called a tuple: each tuple is a predefined list of fields. The data type of each field can be common data types, (e.g., byte, char, string, integer), or your own data types, which can be serialized as fields in a tuple. Each field of a tuple has a name.</span>
<span id="cb3-65"><a href="#cb3-65"></a></span>
<span id="cb3-66"><a href="#cb3-66"></a>A tuple is dynamically typed, that is, you just need to define the names of the fields in a tuple and not their data type.</span>
<span id="cb3-67"><a href="#cb3-67"></a></span>
<span id="cb3-68"><a href="#cb3-68"></a>Storm processes streams of tuples. Each stream </span>
<span id="cb3-69"><a href="#cb3-69"></a></span>
<span id="cb3-70"><a href="#cb3-70"></a><span class="ss">- </span>is an unbounded sequence of tuples</span>
<span id="cb3-71"><a href="#cb3-71"></a><span class="ss">- </span>has a name</span>
<span id="cb3-72"><a href="#cb3-72"></a><span class="ss">- </span>is composed of homogenous tuples (i.e., tuples with the same structure)</span>
<span id="cb3-73"><a href="#cb3-73"></a></span>
<span id="cb3-74"><a href="#cb3-74"></a>However, each applications can process multiple, heterogonous, data streams.</span>
<span id="cb3-75"><a href="#cb3-75"></a></span>
<span id="cb3-76"><a href="#cb3-76"></a>:::{.callout-note collapse="true"}</span>
<span id="cb3-77"><a href="#cb3-77"></a><span class="fu">### Example</span></span>
<span id="cb3-78"><a href="#cb3-78"></a>Tuple</span>
<span id="cb3-79"><a href="#cb3-79"></a></span>
<span id="cb3-80"><a href="#cb3-80"></a><span class="in">```</span></span>
<span id="cb3-81"><a href="#cb3-81"></a><span class="in">(1.1.1.1,"foo.com")</span></span>
<span id="cb3-82"><a href="#cb3-82"></a><span class="in">```</span></span>
<span id="cb3-83"><a href="#cb3-83"></a></span>
<span id="cb3-84"><a href="#cb3-84"></a>Stream of tuples</span>
<span id="cb3-85"><a href="#cb3-85"></a></span>
<span id="cb3-86"><a href="#cb3-86"></a><span class="in">```</span></span>
<span id="cb3-87"><a href="#cb3-87"></a><span class="in">(1.1.1.1,"foo.com")</span></span>
<span id="cb3-88"><a href="#cb3-88"></a><span class="in">(2.2.2.2,"bar.net")</span></span>
<span id="cb3-89"><a href="#cb3-89"></a><span class="in">(3.3.3.3,"foo.com")</span></span>
<span id="cb3-90"><a href="#cb3-90"></a><span class="in">...</span></span>
<span id="cb3-91"><a href="#cb3-91"></a><span class="in">```</span></span>
<span id="cb3-92"><a href="#cb3-92"></a></span>
<span id="cb3-93"><a href="#cb3-93"></a>:::</span>
<span id="cb3-94"><a href="#cb3-94"></a></span>
<span id="cb3-95"><a href="#cb3-95"></a><span class="fu">### Spout</span></span>
<span id="cb3-96"><a href="#cb3-96"></a>Spout is the component generating/handling the input data stream. Spouts read or listen to data from external sources and publish them (emit in Storm terminology) into streams.</span>
<span id="cb3-97"><a href="#cb3-97"></a></span>
<span id="cb3-98"><a href="#cb3-98"></a>:::{.callout-note collapse="true"}</span>
<span id="cb3-99"><a href="#cb3-99"></a><span class="fu">### Examples</span></span>
<span id="cb3-100"><a href="#cb3-100"></a><span class="ss">- </span>A spout can be used to connect to the Twitter API and emit a stream of tweets</span>
<span id="cb3-101"><a href="#cb3-101"></a><span class="ss">- </span>A spout can be used to read a log file and emit a stream of composed of the its lines</span>
<span id="cb3-102"><a href="#cb3-102"></a></span>
<span id="cb3-103"><a href="#cb3-103"></a>:::</span>
<span id="cb3-104"><a href="#cb3-104"></a></span>
<span id="cb3-105"><a href="#cb3-105"></a>Each spout can emit multiple streams, with different schemas; for example, it is possible to implement a spout that reads 10-field records from a log file and emits them as two different streams of 7-tuples and 4-tuples, respectively. </span>
<span id="cb3-106"><a href="#cb3-106"></a></span>
<span id="cb3-107"><a href="#cb3-107"></a>Spouts can be</span>
<span id="cb3-108"><a href="#cb3-108"></a></span>
<span id="cb3-109"><a href="#cb3-109"></a><span class="ss">- </span>unreliable (fire-and-forget)</span>
<span id="cb3-110"><a href="#cb3-110"></a><span class="ss">- </span>reliable (can replay failed tuples)</span>
<span id="cb3-111"><a href="#cb3-111"></a></span>
<span id="cb3-112"><a href="#cb3-112"></a><span class="fu">### Bolt</span></span>
<span id="cb3-113"><a href="#cb3-113"></a>Bolt is the component that is used to apply a function over each tuple of a stream. Bolts consume one or more streams, emitted by spouts or other bolts, and potentially produce new streams.</span>
<span id="cb3-114"><a href="#cb3-114"></a></span>
<span id="cb3-115"><a href="#cb3-115"></a>Bolts can be used to </span>
<span id="cb3-116"><a href="#cb3-116"></a></span>
<span id="cb3-117"><a href="#cb3-117"></a><span class="ss">- </span>filter or transform the content of the input streams and emit new data streams that will be processed by other bolts</span>
<span id="cb3-118"><a href="#cb3-118"></a><span class="ss">- </span>process the data streams and store/persist the result of the computation in some of “storage” (files, Databases, ..)</span>
<span id="cb3-119"><a href="#cb3-119"></a></span>
<span id="cb3-120"><a href="#cb3-120"></a>Each bolt can emit multiple streams, with different schemas.</span>
<span id="cb3-121"><a href="#cb3-121"></a></span>
<span id="cb3-122"><a href="#cb3-122"></a>:::{.callout-note collapse="true"}</span>
<span id="cb3-123"><a href="#cb3-123"></a><span class="fu">### Examples</span></span>
<span id="cb3-124"><a href="#cb3-124"></a><span class="ss">- </span>A bolt can be used to extract one field from each tuple of its input stream</span>
<span id="cb3-125"><a href="#cb3-125"></a><span class="ss">- </span>A bolt can be used to join two streams, based on a common field</span>
<span id="cb3-126"><a href="#cb3-126"></a><span class="ss">- </span>A bolt can be used to count the occurrences of a set of URLs</span>
<span id="cb3-127"><a href="#cb3-127"></a></span>
<span id="cb3-128"><a href="#cb3-128"></a>:::</span>
<span id="cb3-129"><a href="#cb3-129"></a></span>
<span id="cb3-130"><a href="#cb3-130"></a>The input streams of a Storm cluster are handled by spouts</span>
<span id="cb3-131"><a href="#cb3-131"></a></span>
<span id="cb3-132"><a href="#cb3-132"></a><span class="ss">- </span>Each spout passes the data streams to bolts, which transform them in some way</span>
<span id="cb3-133"><a href="#cb3-133"></a><span class="ss">- </span>Each bolt either persists the data in some sort of storage or passes it to some other bolts</span>
<span id="cb3-134"><a href="#cb3-134"></a></span>
<span id="cb3-135"><a href="#cb3-135"></a>A Storm program is a chain of bolts making some computations/transformations on the data exposed by spouts and bolts.</span>
<span id="cb3-136"><a href="#cb3-136"></a></span>
<span id="cb3-137"><a href="#cb3-137"></a><span class="fu">### Topology</span></span>
<span id="cb3-138"><a href="#cb3-138"></a>A Storm topology is an abstraction that defines the graph of the computation: it specifies which spouts and bolts are used and how they are connected. A topology can be represented by a direct acyclic graph (DAG), where each node does some kind of processing and eventually forwards it to the next node(s) in the flow (i.e., a topology in Storm wires data and functions via a DAG).</span>
<span id="cb3-139"><a href="#cb3-139"></a></span>
<span id="cb3-140"><a href="#cb3-140"></a><span class="al">![Topology example](images/23_streaming_frameworks/topology_example.png)</span>{width=80%}</span>
<span id="cb3-141"><a href="#cb3-141"></a></span>
<span id="cb3-142"><a href="#cb3-142"></a><span class="al">![Functional programming](images/23_streaming_frameworks/functional_programming.png)</span>{width=80%}</span>
<span id="cb3-143"><a href="#cb3-143"></a></span>
<span id="cb3-144"><a href="#cb3-144"></a><span class="al">![Topology example](images/23_streaming_frameworks/topology_example_2.png)</span>{width=80%}</span>
<span id="cb3-145"><a href="#cb3-145"></a></span>
<span id="cb3-146"><a href="#cb3-146"></a><span class="ss">- </span>Notice that there are two input data streams in this topology</span>
<span id="cb3-147"><a href="#cb3-147"></a><span class="ss">- </span>There are also two output data streams</span>
<span id="cb3-148"><a href="#cb3-148"></a></span>
<span id="cb3-149"><a href="#cb3-149"></a><span class="fu">#### Topology execution</span></span>
<span id="cb3-150"><a href="#cb3-150"></a>The topology is executed on the servers of the cluster running Storm. The system automatically decides which parts of the topology are executed by each server of the cluster</span>
<span id="cb3-151"><a href="#cb3-151"></a></span>
<span id="cb3-152"><a href="#cb3-152"></a><span class="ss">- </span>Each topology runs until its is explicitly killed</span>
<span id="cb3-153"><a href="#cb3-153"></a><span class="ss">- </span>Each cluster can runs multiple topologies at the same time</span>
<span id="cb3-154"><a href="#cb3-154"></a></span>
<span id="cb3-155"><a href="#cb3-155"></a><span class="fu">##### Worker processes</span></span>
<span id="cb3-156"><a href="#cb3-156"></a><span class="ss">- </span>Each node in the cluster can run one or more JVMs called worker processes that are responsible for processing a part of the topology.</span>
<span id="cb3-157"><a href="#cb3-157"></a><span class="ss">- </span>Each topology executes across one or more worker processes</span>
<span id="cb3-158"><a href="#cb3-158"></a><span class="ss">- </span>Each worker process is bound to one of the topologies and can execute multiple components (spouts and/or bolts) of that topology; hence, even if multiple topologies are run at the same time, none of them will share any of the workers</span>
<span id="cb3-159"><a href="#cb3-159"></a></span>
<span id="cb3-160"><a href="#cb3-160"></a><span class="fu">##### Executor</span></span>
<span id="cb3-161"><a href="#cb3-161"></a><span class="ss">- </span>Within each worker process, there can be multiple threads that execute parts of the topology. Each of these threads is called an executor</span>
<span id="cb3-162"><a href="#cb3-162"></a><span class="ss">- </span>An executor can execute only one of the components of the topology, that is, any one spout or bolt in the topology, but it may run one or more tasks for the same component</span>
<span id="cb3-163"><a href="#cb3-163"></a><span class="ss">- </span>Each spout or bolt can be associated with many executors and hence executed in parallel</span>
<span id="cb3-164"><a href="#cb3-164"></a></span>
<span id="cb3-165"><a href="#cb3-165"></a><span class="fu">##### Tasks</span></span>
<span id="cb3-166"><a href="#cb3-166"></a>A task is the most granular unit of task execution in Storm: each task is an instance of a spout or bolt, and it performs the actual data processing</span>
<span id="cb3-167"><a href="#cb3-167"></a></span>
<span id="cb3-168"><a href="#cb3-168"></a><span class="ss">- </span>Each spout or bolt that you implement in your code executes as many tasks across the cluster</span>
<span id="cb3-169"><a href="#cb3-169"></a><span class="ss">- </span>Each task can be executed alone or with another task of the same type (in the same executor)</span>
<span id="cb3-170"><a href="#cb3-170"></a></span>
<span id="cb3-171"><a href="#cb3-171"></a>The number of tasks for a component is always the same throughout the lifetime of a topology (it is set when the topology is submitted), but the number of executors (threads) for a component can change over time (i.e., it is possible to add/remove executors for each component).</span>
<span id="cb3-172"><a href="#cb3-172"></a></span>
<span id="cb3-173"><a href="#cb3-173"></a>The parallelism of the topology is given by the number of executors (i.e., number of threads). For each spout/bolt the application can specify</span>
<span id="cb3-174"><a href="#cb3-174"></a></span>
<span id="cb3-175"><a href="#cb3-175"></a><span class="ss">- </span>The number of executors: this value can be changed at runtime</span>
<span id="cb3-176"><a href="#cb3-176"></a><span class="ss">- </span>The number of tasks: this value is set before submitting the topology and cannot be change at runtime</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>