<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Distributed architectures for big data processing and analytics - 26&nbsp; Streaming data analytics frameworks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./22_structured_streaming.html" rel="next">
<link href="./20_graph_analytics_2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Distributed architectures for big data processing and analytics</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Index</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_01_intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Big data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_architectures.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Big data architectures</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03b_HDFS_clc.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">HDFS and Hadoop: command line commands</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_intro_hadoop.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Hadoop and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_hadoop_implementation.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">How to write MapReduce programs in Hadoop</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_mapreduce_patterns_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">MapReduce patterns - 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_mapreduce_advanced_topics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">MapReduce and Hadoop Advanced Topics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_mapreduce_patterns_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">MapReduce patterns - 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_sql_operators_mapreduce.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Relational Algebra Operations and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b_spark_submit_execute.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">How to submit/execute a Spark application</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_intro_spark.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_rdd_based_programming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">RDD based programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_rdd_keyvalue_pairs.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">RDDs and key-value pairs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13_rdd_numbers.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">RDD of numbers</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14_cache_accumulators_broadcast.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Cache, Accumulators, Broadcast Variables</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15b_pagerank.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introduction to PageRank</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16_sparksql_dataframes.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Spark SQL and DataFrames</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18a_spark_mllib.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18b_classification.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18c_clustering.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Clustering algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18d_regression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Regression algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18e_mining.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Itemset and Association rule mining</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19_graph_analytics_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Graph analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_graph_analytics_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Graph Analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21_streaming_analytics.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22_structured_streaming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23_streaming_frameworks.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#spark-streaming" id="toc-spark-streaming" class="nav-link" data-scroll-target="#spark-streaming">Spark Streaming</a></li>
  <li><a href="#spark-streaming-programs" id="toc-spark-streaming-programs" class="nav-link" data-scroll-target="#spark-streaming-programs">Spark streaming programs</a></li>
  <li><a href="#windowed-computation" id="toc-windowed-computation" class="nav-link" data-scroll-target="#windowed-computation">Windowed computation</a></li>
  <li><a href="#stateful-computation" id="toc-stateful-computation" class="nav-link" data-scroll-target="#stateful-computation">Stateful computation</a></li>
  <li><a href="#transform-transformation" id="toc-transform-transformation" class="nav-link" data-scroll-target="#transform-transformation">Transform transformation</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">Introduction</h3>
<section id="what-is-streaming-processing" class="level4">
<h4 class="anchored" data-anchor-id="what-is-streaming-processing">What is streaming processing?</h4>
<p>Streaming processing is the act of continuously incorporating new data to compute a result. Input data is unbounded (i.e., it has no beginning and no end). Series of events that arrive at the stream processing system, and the application will output multiple versions of the results as it runs or put them in a storage.</p>
<p>Many important applications must process large streams of live data and provide results in near-real-time</p>
<ul>
<li>Social network trends</li>
<li>Website statistics</li>
<li>Intrusion detection systems</li>
<li>…</li>
</ul>
<p>The main advantages of stream processing are:</p>
<ul>
<li>Vastly higher throughput in data processing</li>
<li>Low latency: application respond quickly (e.g., in seconds). It can keep states in memory</li>
<li>More efficient in updating a result than repeated batch jobs, because it automatically incrementalizes the computation</li>
</ul>
<p>Some requirements and challenges are:</p>
<ul>
<li>Scalable to large clusters</li>
<li>Responding to events at low latency</li>
<li>Simple programming model</li>
<li>Processing each event exactly once despite machine failures - Efficient fault-tolerance in stateful computations</li>
<li>Processing out-of-order data based on application timestamps (also called event time)</li>
<li>Maintaining large amounts of state</li>
<li>Handling load imbalance and stragglers</li>
<li>Updating your application’s business logic at runtime</li>
</ul>
</section>
<section id="stream-processing-frameworks-for-big-streaming-data-analytics" class="level4">
<h4 class="anchored" data-anchor-id="stream-processing-frameworks-for-big-streaming-data-analytics">Stream processing frameworks for big streaming data analytics</h4>
<p>Several frameworks have been proposed to process in real-time or in near real-time data streams</p>
<ul>
<li>Apache Spark (Streaming component)</li>
<li>Apache Storm</li>
<li>Apache Flink</li>
<li>Apache Samza</li>
<li>Apache Apex</li>
<li>Apache Flume</li>
<li>Amazon Kinesis Streams</li>
<li>…</li>
</ul>
<p>All these frameworks use a cluster of servers to scale horizontally with respect to the (big) amount of data to be analyzed.</p>
<section id="main-solutions" class="level5">
<h5 class="anchored" data-anchor-id="main-solutions">Main solutions</h5>
<p>There are two main solutions</p>
<ul>
<li><strong>Continuous computation of data streams</strong>. In this case, data are processed as soon as they arrive: every time a new record arrives from the input stream, it is immediately processed and a result is emitted as soon as possible. This is real-time processing.</li>
<li><strong>Micro-batch stream processing</strong>. Input data are collected in micro-batches, where each micro-batch contains all the data received in a time window (typically less than a few seconds of data). One micro-batch a time is processed: every time a micro-batch of data is ready, its entire content is processed and a result is emitted. This is near real-time processing.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Continuous computation: one record at a time</figcaption><p></p>
<p><img src="images/21_streaming_analytics/continuous_computation.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Micro-batch computation: one micro-batch at a time</figcaption><p></p>
<p><img src="images/21_streaming_analytics/microbatch_computation.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
</section>
<section id="input-data-processing-and-result-guarantees" class="level4">
<h4 class="anchored" data-anchor-id="input-data-processing-and-result-guarantees">Input data processing and result guarantees</h4>
<ul>
<li>At-most-once
<ul>
<li>Every input element of a stream is processed once or less</li>
<li>It is also called no guarantee</li>
<li>The result can be wrong/approximated</li>
</ul></li>
<li>At-least-once
<ul>
<li>Every input element of a stream is processed once or more</li>
<li>Input elements are replayed when there are failures</li>
<li>The result can be wrong/approximated</li>
</ul></li>
<li>Exactly-once
<ul>
<li>Every input element of a stream is processed exactly once</li>
<li>Input elements are replayed when there are failures</li>
<li>If elements have been already processed they are not reprocessed</li>
<li>The result is always correct</li>
<li>Slower than the other processing approaches</li>
</ul></li>
</ul>
</section>
</section>
<section id="spark-streaming" class="level3">
<h3 class="anchored" data-anchor-id="spark-streaming">Spark Streaming</h3>
<section id="what-is-spark-streaming" class="level4">
<h4 class="anchored" data-anchor-id="what-is-spark-streaming">What is Spark Streaming</h4>
<p>Spark Streaming is a framework for large scale stream processing</p>
<ul>
<li>Scales to 100s of nodes</li>
<li>Can achieve second scale latencies</li>
<li>Provides a simple batch-like API for implementing complex algorithm</li>
<li>Micro-batch streaming processing</li>
<li>Exactly-once guarantees</li>
<li>Can absorb live data streams from Kafka, Flume, ZeroMQ, Twitter, …</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Spark Streaming components</figcaption><p></p>
<p><img src="images/21_streaming_analytics/spark_streaming_components.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Many important applications must process large streams of live data and provide results in near-real-time</p>
<ul>
<li>Social network trends</li>
<li>Website statistics</li>
<li>Intrusion detection systems</li>
<li>…</li>
</ul>
<p>The requirements are</p>
<ul>
<li>Scalable to large clusters</li>
<li>Second-scale latencies</li>
<li>Simple programming model</li>
<li>Efficient fault-tolerance in stateful computations</li>
</ul>
</section>
<section id="spark-discretized-stream-processing" class="level4">
<h4 class="anchored" data-anchor-id="spark-discretized-stream-processing">Spark discretized stream processing</h4>
<p>Spark streaming runs a streaming computation as a series of very small, deterministic batch jobs. It splits each input stream in portions and processes one portion at a time (in the incoming order): the same computation is applied on each portion (called <strong>batch</strong>) of the stream.</p>
<p>So, Spark streaming</p>
<ul>
<li>Splits the live stream into batches of X seconds</li>
<li>Treats each batch of data as RDDs and processes them using RDD operations</li>
<li>Finally, the processed results of the RDD operations are returned in batches</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Discretization in batches</figcaption><p></p>
<p><img src="images/21_streaming_analytics/discretization.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Word count implementation using Spark streaming. Problem specification:</p>
<ul>
<li>The input is a stream of sentences</li>
<li>Split the input stream in batches of 10 seconds each and print on the standard output, for each batch, the occurrences of each word appearing in the batch (i.e., execute the word count application one time for each batch of 10 seconds)</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Input and output</figcaption><p></p>
<p><img src="images/21_streaming_analytics/wordcount_input_output.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</div>
</div>
</div>
<div class="callout-tip callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Key concepts
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>DSream
<ul>
<li>Sequence of RDDs representing a discretized version of the input stream of data (Twitter, HDFS, Kafka, Flume, ZeroMQ, Akka Actor, TCP sockets, …)</li>
<li>One RDD for each batch of the input stream</li>
</ul></li>
<li>Transformations
<ul>
<li>Modify data from one DStream to another</li>
<li>Standard RDD operations (map, countByValue, reduce, join, …)</li>
<li>Window and Stateful operations (window, countByValueAndWindow, …)</li>
</ul></li>
<li>Output Operations/Actions
<ul>
<li>Send data to external entity (saveAsHadoopFiles, saveAsTextFile, …)</li>
</ul></li>
</ul>
</div>
</div>
</section>
<section id="word-count-using-dstreams" class="level4">
<h4 class="anchored" data-anchor-id="word-count-using-dstreams">Word count using DStreams</h4>
<p>A DStream is represented by a continuous series of RDDs. Each RDD in a DStream contains data from a certain batch/interval.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">RDDs composing a DStreams</figcaption><p></p>
<p><img src="images/21_streaming_analytics/wordcount_dstreams.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Any operation applied on a DStream translates to operations on the underlying RDDs. These underlying RDD transformations are computed by the Spark engine.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Operations in a DStreams</figcaption><p></p>
<p><img src="images/21_streaming_analytics/wordcount_dstreams_operations.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="fault-tolerance" class="level4">
<h4 class="anchored" data-anchor-id="fault-tolerance">Fault-tolerance</h4>
<p>DStreams remember the sequence of operations that created them from the original fault-tolerant input data. Batches of input data are replicated in memory of multiple worker nodes, therefore fault-tolerant: data lost due to worker failure, can be recomputed from input data.</p>
</section>
</section>
<section id="spark-streaming-programs" class="level3">
<h3 class="anchored" data-anchor-id="spark-streaming-programs">Spark streaming programs</h3>
<section id="basic-structure-of-a-spark-streaming-program" class="level4">
<h4 class="anchored" data-anchor-id="basic-structure-of-a-spark-streaming-program">Basic structure of a Spark streaming program</h4>
<ol type="1">
<li>Define a Spark Streaming Context object. Define the size of the batches (in seconds) associated with the Streaming context.</li>
<li>Specify the input stream and define a DStream based on it</li>
<li>Specify the operations to execute for each batch of data</li>
<li>Use transformations and actions similar to the ones available for standard RDDs</li>
<li>Invoke the start method, to start processing the input stream</li>
<li>Wait until the application is killed or the timeout specified in the application expires: if the timeout is not set and the application is not killed the application will run forever</li>
</ol>
</section>
<section id="spark-streaming-context" class="level4">
<h4 class="anchored" data-anchor-id="spark-streaming-context">Spark streaming context</h4>
<p>The Spark Streaming Context is defined by using the <code>StreamingContext(SparkConf sparkC, Duration batchDuration)</code> constructor of the class <code>pyspark.streaming.StreamingContext</code>. The <code>batchDuration</code> parameter specifies the size of the batches in seconds</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> pyspark.streaming <span class="im">import</span> StreamingContext</span>
<span id="cb1-2"><a href="#cb1-2"></a>ssc <span class="op">=</span> StreamingContext(sc, <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The input streams associated with this context will be split in batches of 10 seconds.</p>
</div>
</div>
</div>
<p>After a context is defined, the next steps are</p>
<ul>
<li>Define the input sources by creating input Dstreams</li>
<li>Define the streaming computations by applying transformation and output operations to DStreams</li>
</ul>
</section>
<section id="input-streams" class="level4">
<h4 class="anchored" data-anchor-id="input-streams">Input streams</h4>
<p>The input Streams can be generated from different sources</p>
<ul>
<li>TCP socket, Kafka, Flume, Kinesis, Twitter.</li>
<li>Also a HDFS folder can be used as input stream. This option is usually used during the application development to perform a set of initial tests.</li>
</ul>
<section id="input-tcp-socket" class="level5">
<h5 class="anchored" data-anchor-id="input-tcp-socket">Input: TCP socket</h5>
<p>A DStream can be associated with the content emitted by a TCP socket: <code>socketTextStream(String hostname, int port_number)</code> is used to create a DStream based on the textual content emitted by a TCP socket.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>lines <span class="op">=</span> ssc.socketTextStream(<span class="st">"localhost"</span>, <span class="dv">9999</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It stores the content emitted by localhost:9999 in the lines DStream.</p>
</div>
</div>
</div>
</section>
<section id="input-hdfs-folder" class="level5">
<h5 class="anchored" data-anchor-id="input-hdfs-folder">Input: (HDFS) folder</h5>
<p>A DStream can be associated with the content of an input (HDFS) folder: every time a new file is inserted in the folder, the content of the file is stored in the associated DStream and processed. Pay attention that updating the content of a file does not trigger/change the content of the DStream. <code>textFileStream(String folder)</code> is used to create a DStream based on the content of the input folder.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>lines <span class="op">=</span> textFileStream(inputFolder)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Store the content of the files inserted in the input folder in the lines Dstream: every time new files are inserted in the folder their content is stored in the current batch of the stream.</p>
</div>
</div>
</div>
</section>
<section id="input-other-sources" class="level5">
<h5 class="anchored" data-anchor-id="input-other-sources">Input: other sources</h5>
<p>Usually DStream objects are defined on top of streams emitted by specific applications that emit real-time streaming data (e.g., Apache Kafka, Apache Flume, Kinesis, Twitter). It is also possible to write custom applications for generating streams of data, however Kafka, Flume and similar tools are usually a more reliable and effective solutions for generating streaming data.</p>
</section>
</section>
<section id="transformations" class="level4">
<h4 class="anchored" data-anchor-id="transformations">Transformations</h4>
<p>Analogously to standard RDDs, also DStreams are characterized by a set of transformations that, when applied to DStream objects, return a new DStream Object. The transformation is applied on one batch (RDD) of the input DStream at a time and returns a batch (RDD) of the new DStream (i.e., each batch (RDD) of the input DStream is associated with exactly one batch (RDD) of the returned DStream). Many of the available transformations are the same transformations available for standard RDDs.</p>
<section id="basic-transformations" class="level5">
<h5 class="anchored" data-anchor-id="basic-transformations">Basic transformations</h5>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>Transformation</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>map(func)</code></td>
<td>It returns a new DStream by passing each element of the source DStream through a function func.</td>
</tr>
<tr class="even">
<td><code>flatMap(func)</code></td>
<td>each input item can be mapped to 0 or more output items. Returns a new DStream.</td>
</tr>
<tr class="odd">
<td><code>filter(func)</code></td>
<td>It returns a new DStream by selecting only the records of the source DStream on which func returns true.</td>
</tr>
<tr class="even">
<td><code>reduce(func)</code></td>
<td>It returns a new DStream of single-element RDDs by aggregating the elements in each RDD of the source DStream using a function func. The function must be associative and commutative so that it can be computed in parallel. Note that the <code>reduce</code> method of DStreams is a transformation.</td>
</tr>
<tr class="odd">
<td><code>reduceByKey(func)</code></td>
<td>When called on a DStream of <span class="math inline">\((K, V)\)</span> pairs, returns a new DStream of <span class="math inline">\((K, V)\)</span> pairs where the values for each key are aggregated using the given reduce function.</td>
</tr>
<tr class="even">
<td><code>combineByKey(...)</code></td>
<td>when called on a DStream of <span class="math inline">\((K, V)\)</span> pairs, returns a new DStream of <span class="math inline">\((K, W)\)</span> pairs where the values for each key are aggregated using the given combine functions. The parameters are: <code>createCombiner</code>, <code>mergeValue</code>, and <code>mergeCombiners</code></td>
</tr>
<tr class="odd">
<td><code>groupByKey()</code></td>
<td>when called on a DStream of <span class="math inline">\((K, V)\)</span> pairs, returns a new DStream of <span class="math inline">\((K, \text{Iterable&lt;V&gt;})\)</span> pairs where the values for each key is the concatenation of all the values associated with key <span class="math inline">\(K\)</span> (i.e., It returns a new DStream by applying groupByKey on one batch (one RDD) of the input stream at a time).</td>
</tr>
<tr class="even">
<td><code>countByValue()</code></td>
<td>when called on a DStream of elements of type <span class="math inline">\(K\)</span>, returns a new DStream of <span class="math inline">\((K, \text{Long})\)</span> pairs where the value of each key is its frequency in each batch of the source Dstream. Note that the <code>countByValue</code> method of DStreams is a transformation.</td>
</tr>
<tr class="odd">
<td><code>count()</code></td>
<td>It returns a new DStream of single-element RDDs by counting the number of elements in each batch (RDD) of the source Dstream (i.e., it counts the number of elements in each input batch (RDD)). Note that the <code>count</code> method of DStreams is a transformation.</td>
</tr>
<tr class="even">
<td><code>union(otherStream)</code></td>
<td>It returns a new DStream that contains the union of the elements in the source DStream and otherDStream.</td>
</tr>
<tr class="odd">
<td><code>join(otherStream)</code></td>
<td>when called on two DStreams of <span class="math inline">\((K, V)\)</span> and <span class="math inline">\((K, W)\)</span> pairs, return a new DStream of <span class="math inline">\((K, (V, W))\)</span> pairs with all pairs of elements for each key.</td>
</tr>
<tr class="even">
<td><code>cogroup(otherStream)</code></td>
<td>when called on a DStream of <span class="math inline">\((K, V)\)</span> and <span class="math inline">\((K, W)\)</span> pairs, return a new DStream of <span class="math inline">\((K, \text{Seq}[V], \text{Seq}[W])\)</span> tuples.</td>
</tr>
</tbody>
</table>
</section>
<section id="basic-actions" class="level5">
<h5 class="anchored" data-anchor-id="basic-actions">Basic actions</h5>
<p>Action | Effect |<br>
<code>pprint()</code> | It prints the first 10 elements of every batch of data in a DStream on the standard output of the driver node running the streaming application. It is useful for development and debugging |<br>
<code>saveAsTextFiles(prefix, [suffix])</code> | It saves the content of the DStream on which it is invoked as text files: one folder for each batch, and the folder name at each batch interval is generated based on prefix, time of the batch (and suffix): “prefix-TIME_IN_MS[.suffix]” (e.g., <code>Counts.saveAsTextFiles(outputPathPrefix, "")</code>). |</p>
</section>
</section>
<section id="start-and-run-the-computations" class="level4">
<h4 class="anchored" data-anchor-id="start-and-run-the-computations">Start and run the computations</h4>
<p>The <code>streamingContext.start()</code> method is used to start the application on the input stream(s). The <code>awaitTerminationOrTimeout(long millisecons)</code> method is used to specify how long the application will run.</p>
<p>The <code>awaitTermination()</code> method is used to run the application forever</p>
<ul>
<li>Until the application is explicitly killed</li>
<li>The processing can be manually stopped using <code>streamingContext.stop()</code></li>
</ul>
<section id="points-to-remember" class="level5">
<h5 class="anchored" data-anchor-id="points-to-remember">Points to remember</h5>
<ul>
<li>Once a context has been started, no new streaming computations can be set up or added to it</li>
<li>Once a context has been stopped, it cannot be restarted</li>
<li>Only one StreamingContext per application can be active at the same time</li>
<li><code>stop()</code> on StreamingContext also stops the SparkContext. To stop only the <code>StreamingContext</code>, set the optional parameter of <code>stop()</code> called <code>stopSparkContext</code> to False</li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example: Spark Streaming version of word count
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Problem specification</p>
<ul>
<li>Input: a stream of sentences retrieved from localhost:9999</li>
<li>Task:
<ul>
<li>Split the input stream in batches of 5 seconds each and print on the standard output, for each batch, the occurrences of each word appearing in the batch (i.e., execute the word count problem for each batch of 5 seconds)</li>
<li>Store the results also in an HDFS folder</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> pyspark.streaming <span class="im">import</span> StreamingContext</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">## Set prefix of the output folders</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>outputPathPrefix<span class="op">=</span><span class="st">"resSparkStreamingExamples"</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#Create a configuration object and#set the name of the applicationconf</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>SparkConf().setAppName(<span class="st">"Streaming word count"</span>)</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">## Create a Spark Context object</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>sc <span class="op">=</span> SparkContext(conf<span class="op">=</span>conf)</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">## Create a Spark Streaming Context object</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>ssc <span class="op">=</span> StreamingContext(sc, <span class="dv">5</span>)</span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">## Create a (Receiver) DStream that will connect to localhost:9999</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>lines <span class="op">=</span> ssc.socketTextStream(<span class="st">"localhost"</span>, <span class="dv">9999</span>)</span>
<span id="cb4-17"><a href="#cb4-17"></a></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co">## Apply a chain of transformations to perform the word count task</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="co">## The returned RDDs are DStream RDDs</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>words <span class="op">=</span> lines.flatMap(<span class="kw">lambda</span> line: line.split(<span class="st">" "</span>))</span>
<span id="cb4-21"><a href="#cb4-21"></a>wordsOnes <span class="op">=</span> words.<span class="bu">map</span>(<span class="kw">lambda</span> word: (word, <span class="dv">1</span>))</span>
<span id="cb4-22"><a href="#cb4-22"></a>wordsCounts <span class="op">=</span> wordsOnes.reduceByKey(<span class="kw">lambda</span> v1, v2: v1<span class="op">+</span>v2)</span>
<span id="cb4-23"><a href="#cb4-23"></a></span>
<span id="cb4-24"><a href="#cb4-24"></a><span class="co">## Print the result on the standard output</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>wordsCounts.pprint()</span>
<span id="cb4-26"><a href="#cb4-26"></a></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="co">## Store the result in HDFS</span></span>
<span id="cb4-28"><a href="#cb4-28"></a>wordsCounts.saveAsTextFiles(outputPathPrefix, <span class="st">""</span>)</span>
<span id="cb4-29"><a href="#cb4-29"></a></span>
<span id="cb4-30"><a href="#cb4-30"></a><span class="co">#Start the computation</span></span>
<span id="cb4-31"><a href="#cb4-31"></a>ssc.start()</span>
<span id="cb4-32"><a href="#cb4-32"></a></span>
<span id="cb4-33"><a href="#cb4-33"></a><span class="co">## Run this application for 90 seconds</span></span>
<span id="cb4-34"><a href="#cb4-34"></a>ssc.awaitTerminationOrTimeout(<span class="dv">90</span>)</span>
<span id="cb4-35"><a href="#cb4-35"></a>ssc.stop(stopSparkContext<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="windowed-computation" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="windowed-computation">Windowed computation</h3>
<p>Spark Streaming also provides windowed computations, allowing to apply transformations over a sliding window of data: each window contains a set of batches of the inputstream, and windows can be overlapped (i.e., the same batch can be included in many consecutive windows).</p>
<p>Every time the window slides over a source DStream, the source RDDs that fall within the window are combined and operated upon to produce the RDDs of the windowed DStream.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Graphical example</figcaption><p></p>
<p><img src="images/21_streaming_analytics/windows_graphical_example.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>In the example, the operationis applied over the last 3 time units of data (i.e., the last 3 batches of the input DStream), and each window contains the data of 3 batches. It slides by 2 time units.</p>
<section id="parameters" class="level4">
<h4 class="anchored" data-anchor-id="parameters">Parameters</h4>
<p>Any window operation needs to specify two parameters</p>
<ul>
<li>Window length: the duration of the window (3 in the example)</li>
<li>Sliding interval: the interval at which the window operation is performed (2 in the example)</li>
</ul>
<p>These two parameters must be multiples of the batch interval of the source DStream.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example: word count and window
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Problem specification</p>
<ul>
<li>Input: a stream of sentences</li>
<li>Split the input stream in batches of 10 seconds</li>
<li>Define widows with the following characteristics
<ul>
<li>Window length: 20 seconds (i.e., 2 batches)</li>
<li>Sliding interval: 10 seconds (i.e., 1 batch)</li>
</ul></li>
<li>Print on the standard output, for each window, the occurrences of each word appearing in the window (i.e., execute the word count problem for each window)</li>
</ul>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step one</figcaption><p></p>
<p><img src="images/21_streaming_analytics/wordcount_window_1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step two</figcaption><p></p>
<p><img src="images/21_streaming_analytics/wordcount_window_2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: center;">
<p>Word count and windows</p>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="basic-window-transformations" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="basic-window-transformations">Basic window transformations</h4>
<div class="page-columns page-full">
<div class="column-screen-inset">
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>Window transformation</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>window(windowLength, slideInterval)</code></td>
<td>It returns a new DStream which is computed based on windowed batches of the source DStream.</td>
</tr>
<tr class="even">
<td><code>countByWindow(windowLength, slideInterval)</code></td>
<td>It returns a new single-element stream containing the number of elements of each window. The returned object is a Dstream of Long objects. However, it contains only one value for each window (the number of elements of the last analyzed window).</td>
</tr>
<tr class="odd">
<td><code>reduceByWindow(reduceFunc, invReduceFunc, windowDuration, slideDuration)</code></td>
<td>It returns a new single-element stream, created by aggregating elements in the stream over a sliding interval using <code>func</code>. The function must be associative and commutative so that it can be computed correctly in parallel. If <code>invReduceFunc</code> is not None, the reduction is done incrementally using the old window’s reduced value.</td>
</tr>
<tr class="even">
<td><code>countByValueAndWindow(windowDuration , slideDuration)</code></td>
<td>When called on a DStream of elements of type <span class="math inline">\(K\)</span>, it returns a new DStream of <span class="math inline">\((K, \text{Long})\)</span> pairs where the value of each key <span class="math inline">\(K\)</span> is its frequency in each window of the source DStream.</td>
</tr>
<tr class="odd">
<td><code>reduceByKeyAndWindow(func, invFunc, windowDuration, slideDuration=None, numPartitions=None)</code></td>
<td>When called on a DStream of <span class="math inline">\((K, V)\)</span> pairs, it returns a new DStream of <span class="math inline">\((K, V)\)</span> pairs where the values for each key are aggregated using the given reduce function func over batches in a sliding window. The window duration (length) is specified as a parameter of this invocation (<code>windowDuration</code>). Notice that, if <code>slideDuration</code> is None, the <code>batchDuration</code> of the StreamingContext object is used (i.e., 1 batch sliding window); if <code>invFunc</code> is provideved (is not None), the reduction is done incrementally using the old window’s reduced values (i.e., <code>invFunc</code> is used to apply an inverse reduce operation by considering the old values that left the window, e.g., subtracting old counts).</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section id="checkpoint" class="level4">
<h4 class="anchored" data-anchor-id="checkpoint">Checkpoint</h4>
<p>A streaming application must operate 24/7 and hence must be resilient to failures unrelated to the application logic (e.g., system failures, JVM crashes, etc.). For this to be possible, Spark Streaming needs to checkpoint enough information to a fault- tolerant storage system such that it can recover from failures, and this result is achieved by means of checkpoints, which are operations that store the data and metadata needed to restart the computation if failures happen. Checkpointing is necessary even for some window transformations and stateful transformations.</p>
<p>Checkpointing is enabled by using the <code>checkpoint(String folder)</code> method of <code>SparkStreamingContext</code>: the parameter is the folder that is used to store temporary data. This is similar as for processing graphs with GraphFrames library, however, with GraphFrames, the checkpoint was the one of SparkContext.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example: word count and windows
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Problem specification</p>
<ul>
<li>Input: a stream of sentences retrieved from localhost:9999</li>
<li>Split the input stream in batches of 5 seconds</li>
<li>Define widows with the following characteristics
<ul>
<li>Window length: 15 seconds (i.e., 3 batches)</li>
<li>Sliding interval: 5 seconds (i.e., 1 batch)</li>
</ul></li>
<li>Print on the standard output, for each window, the occurrences of each word appearing in the window (i.e., execute the word count problem for each window)</li>
<li>Store the results also in an HDFS folder</li>
</ul>
<p><strong>First solution</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> pyspark.streaming <span class="im">import</span> StreamingContext</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">## Set prefix of the output folders</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>outputPathPrefix<span class="op">=</span><span class="st">"resSparkStreamingExamples"</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">#Create a configuration object and#set the name of the applicationconf</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>SparkConf().setAppName(<span class="st">"Streaming word count"</span>)</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">## Create a Spark Context object</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>sc <span class="op">=</span> SparkContext(conf<span class="op">=</span>conf)</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">## Create a Spark Streaming Context object</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>ssc <span class="op">=</span> StreamingContext(sc, <span class="dv">5</span>)</span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">## Set the checkpoint folder (it is needed by some window transformations)</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>ssc.checkpoint(<span class="st">"checkpointfolder"</span>)</span>
<span id="cb5-17"><a href="#cb5-17"></a></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">## Create a (Receiver) DStream that will connect to localhost:9999</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>lines <span class="op">=</span> ssc.socketTextStream(<span class="st">"localhost"</span>, <span class="dv">9999</span>)</span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="co">## Apply a chain of transformations to perform the word count task</span></span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="co">## The returned RDDs are DStream RDDs</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>words <span class="op">=</span> lines.flatMap(<span class="kw">lambda</span> line: line.split(<span class="st">" "</span>))</span>
<span id="cb5-24"><a href="#cb5-24"></a>wordsOnes <span class="op">=</span> words.<span class="bu">map</span>(<span class="kw">lambda</span> word: (word, <span class="dv">1</span>))</span>
<span id="cb5-25"><a href="#cb5-25"></a></span>
<span id="cb5-26"><a href="#cb5-26"></a><span class="co">## reduceByKeyAndWindow is used instead of reduceByKey</span></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co">## The durantion of the window is also specified</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>wordsCounts <span class="op">=</span> wordsOnes <span class="op">\</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>    .reduceByKeyAndWindow(<span class="kw">lambda</span> v1, v2: v1<span class="op">+</span>v2, <span class="va">None</span>, <span class="dv">15</span>)</span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="co">## Print the num. of occurrences of each word of the current window</span></span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="co">## (only 10 of them)</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>wordsCounts.pprint()</span>
<span id="cb5-34"><a href="#cb5-34"></a></span>
<span id="cb5-35"><a href="#cb5-35"></a><span class="co">## Store the output of the computation in the folders with prefix</span></span>
<span id="cb5-36"><a href="#cb5-36"></a><span class="co">## outputPathPrefix</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>wordsCounts.saveAsTextFiles(outputPathPrefix, <span class="st">""</span>)</span>
<span id="cb5-38"><a href="#cb5-38"></a></span>
<span id="cb5-39"><a href="#cb5-39"></a><span class="co">#Start the computation</span></span>
<span id="cb5-40"><a href="#cb5-40"></a>ssc.start()</span>
<span id="cb5-41"><a href="#cb5-41"></a>ssc.awaitTermination ()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Second solution</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> pyspark.streaming <span class="im">import</span> StreamingContext</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">## Set prefix of the output folders</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>outputPathPrefix<span class="op">=</span><span class="st">"resSparkStreamingExamples"</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#Create a configuration object and#set the name of the applicationconf</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>SparkConf().setAppName(<span class="st">"Streaming word count"</span>)</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">## Create a Spark Context object</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>sc <span class="op">=</span> SparkContext(conf<span class="op">=</span>conf)</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">## Create a Spark Streaming Context object</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>ssc <span class="op">=</span> StreamingContext(sc, <span class="dv">5</span>)</span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">## Set the checkpoint folder (it is needed by some window transformations)</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>ssc.checkpoint(<span class="st">"checkpointfolder"</span>)</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">## Create a (Receiver) DStream that will connect to localhost:9999</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>lines <span class="op">=</span> ssc.socketTextStream(<span class="st">"localhost"</span>, <span class="dv">9999</span>)</span>
<span id="cb6-20"><a href="#cb6-20"></a></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="co">## Apply a chain of transformations to perform the word count task</span></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="co">## The returned RDDs are DStream RDDs</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>words <span class="op">=</span> lines.flatMap(<span class="kw">lambda</span> line: line.split(<span class="st">" "</span>))</span>
<span id="cb6-24"><a href="#cb6-24"></a>wordsOnes <span class="op">=</span> words.<span class="bu">map</span>(<span class="kw">lambda</span> word: (word, <span class="dv">1</span>))</span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="co">## reduceByKeyAndWindow is used instead of reduceByKey</span></span>
<span id="cb6-27"><a href="#cb6-27"></a><span class="co">## The durantion of the window is also specified</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>wordsCounts <span class="op">=</span> wordsOnes <span class="op">\</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>    .reduceByKeyAndWindow(</span>
<span id="cb6-30"><a href="#cb6-30"></a>        <span class="kw">lambda</span> v1, v2: v1<span class="op">+</span>v2, </span>
<span id="cb6-31"><a href="#cb6-31"></a>        <span class="co">#lambda vnow, # &lt;1&gt;</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>        vold: vnow<span class="op">-</span>vold, <span class="dv">15</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>    )</span>
<span id="cb6-34"><a href="#cb6-34"></a></span>
<span id="cb6-35"><a href="#cb6-35"></a><span class="co">## Print the num. of occurrences of each word of the current window</span></span>
<span id="cb6-36"><a href="#cb6-36"></a><span class="co">## (only 10 of them)</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>wordsCounts.pprint()</span>
<span id="cb6-38"><a href="#cb6-38"></a></span>
<span id="cb6-39"><a href="#cb6-39"></a><span class="co">## Store the output of the computation in the folders with prefix</span></span>
<span id="cb6-40"><a href="#cb6-40"></a><span class="co">## outputPathPrefix</span></span>
<span id="cb6-41"><a href="#cb6-41"></a>wordsCounts.saveAsTextFiles(outputPathPrefix, <span class="st">""</span>)</span>
<span id="cb6-42"><a href="#cb6-42"></a></span>
<span id="cb6-43"><a href="#cb6-43"></a><span class="co">#Start the computation</span></span>
<span id="cb6-44"><a href="#cb6-44"></a>ssc.start()</span>
<span id="cb6-45"><a href="#cb6-45"></a></span>
<span id="cb6-46"><a href="#cb6-46"></a><span class="co">## Run this application for 90 seconds</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>ssc.awaitTerminationOrTimeout(<span class="dv">90</span>)</span>
<span id="cb6-48"><a href="#cb6-48"></a>ssc.stop(stopSparkContext<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>In this solution the inverse function is also specified in order to compute the result incrementally</li>
</ol>
</div>
</div>
</div>
</section>
</section>
<section id="stateful-computation" class="level3">
<h3 class="anchored" data-anchor-id="stateful-computation">Stateful computation</h3>
<section id="updatestatebykey-transformation" class="level4">
<h4 class="anchored" data-anchor-id="updatestatebykey-transformation"><code>updateStateByKey</code> transformation</h4>
<p>The <code>updateStateByKey</code> transformation allows maintaining a state for each key. The value of the state of each key is continuously updated every time a new batch is analyzed.</p>
<p>The use of <code>updateStateByKey</code> is based on two steps</p>
<ul>
<li>Define the state: the data type of the state associated with the keys can be an arbitrary data type</li>
<li>Define the state update function: specify with a function how to update the state of a key using the previous state and the new values from an input stream associated with that key</li>
</ul>
<p>In every batch, Spark will apply the state update function for all existing keys. For each key, the update function is used to update the value associated with a key by combining the former value and the new values associated with that key; in other words, for each key, the call method of the function is invoked on the list of new values and the former state value and returns the new aggregated value for the considered key.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example: word count and <code>updateStateByKey</code> transformation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>By using the <code>updateStateByKey</code>, the application can continuously update the number of occurrences of each word. The number of occurrences stored in the DStream returned by this transformation is computed over the union of all the batches (from the first one to the current one). For efficiency reasons, the new value for each key is computed by combining the last value for that key with the values of the current batch for the same key.</p>
<p>Problem specification:</p>
<ul>
<li>Input: a stream of sentences retrieved from localhost:9999</li>
<li>Split the input stream in batches of 5 seconds</li>
<li>Print on the standard output, every 5 seconds, the occurrences of each word appearing in the stream (from time 0 to the current time) (i.e., execute the word count problem from the beginning of the stream to current time)</li>
<li>Store the results also in an HDFS folder</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> pyspark.streaming <span class="im">import</span> StreamingContext</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">## Set prefix of the output folders</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>outputPathPrefix<span class="op">=</span><span class="st">"resSparkStreamingExamples"</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">#Create a configuration object and#set the name of the applicationconf</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>SparkConf().setAppName(<span class="st">"Streaming word count"</span>)</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="co">## Create a Spark Context object</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>sc <span class="op">=</span> SparkContext(conf<span class="op">=</span>conf)</span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">## Create a Spark Streaming Context object</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>ssc <span class="op">=</span> StreamingContext(sc, <span class="dv">5</span>)</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="co">## Set the checkpoint folder (it is needed by some window transformations)</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>ssc.checkpoint(<span class="st">"checkpointfolder"</span>)</span>
<span id="cb7-17"><a href="#cb7-17"></a></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="co">## Create a (Receiver) DStream that will connect to localhost:9999</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>lines <span class="op">=</span> ssc.socketTextStream(<span class="st">"localhost"</span>, <span class="dv">9999</span>)</span>
<span id="cb7-20"><a href="#cb7-20"></a></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="co">## Apply a chain of transformations to perform the word count task</span></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="co">## The returned RDDs are DStream RDDs</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>words <span class="op">=</span> lines.flatMap(<span class="kw">lambda</span> line: line.split(<span class="st">" "</span>))</span>
<span id="cb7-24"><a href="#cb7-24"></a>wordsOnes <span class="op">=</span> words.<span class="bu">map</span>(<span class="kw">lambda</span> word: (word, <span class="dv">1</span>))</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="co">## Define the function that is used to update the state of a key at a time</span></span>
<span id="cb7-27"><a href="#cb7-27"></a><span class="co">#def updateFunction(newValues, currentCount): # &lt;1&gt;</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>    <span class="cf">if</span> currentCount <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb7-29"><a href="#cb7-29"></a>        currentCount <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-30"><a href="#cb7-30"></a></span>
<span id="cb7-31"><a href="#cb7-31"></a>    <span class="co">## Sum the new values to the previous state for the current key</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>    <span class="co">#return sum(newValues, currentCount) # &lt;2&gt;</span></span>
<span id="cb7-33"><a href="#cb7-33"></a></span>
<span id="cb7-34"><a href="#cb7-34"></a><span class="co">## DStream made of cumulative counts for each key that get updated </span></span>
<span id="cb7-35"><a href="#cb7-35"></a><span class="co">## in every batch</span></span>
<span id="cb7-36"><a href="#cb7-36"></a><span class="co">#totalWordsCounts = wordsOnes.updateStateByKey(updateFunction) # &lt;3&gt;</span></span>
<span id="cb7-37"><a href="#cb7-37"></a></span>
<span id="cb7-38"><a href="#cb7-38"></a><span class="co">## Print the num. of occurrences of each word of the current window</span></span>
<span id="cb7-39"><a href="#cb7-39"></a><span class="co">## (only 10 of them)</span></span>
<span id="cb7-40"><a href="#cb7-40"></a>totalWordsCounts.pprint()</span>
<span id="cb7-41"><a href="#cb7-41"></a></span>
<span id="cb7-42"><a href="#cb7-42"></a><span class="co">## Store the output of the computation in the folders with prefix</span></span>
<span id="cb7-43"><a href="#cb7-43"></a><span class="co">## outputPathPrefix</span></span>
<span id="cb7-44"><a href="#cb7-44"></a>totalWordsCounts.saveAsTextFiles(outputPathPrefix, <span class="st">""</span>)</span>
<span id="cb7-45"><a href="#cb7-45"></a></span>
<span id="cb7-46"><a href="#cb7-46"></a><span class="co">#Start the computation</span></span>
<span id="cb7-47"><a href="#cb7-47"></a>ssc.start()</span>
<span id="cb7-48"><a href="#cb7-48"></a></span>
<span id="cb7-49"><a href="#cb7-49"></a><span class="co">## Run this application for 90 seconds</span></span>
<span id="cb7-50"><a href="#cb7-50"></a>ssc.awaitTerminationOrTimeout(<span class="dv">90</span>)</span>
<span id="cb7-51"><a href="#cb7-51"></a>ssc.stop(stopSparkContext<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>currentCount</code>: current state/value for the current key</li>
<li><code>newValues</code>: list of new integer values for the current key</li>
<li><code>sum(newValues, currentCount)</code>: Combine current state and new values</li>
<li><code>updateFunction</code>: this function is invoked one time for each key</li>
</ol>
</div>
</div>
</div>
</section>
</section>
<section id="transform-transformation" class="level3">
<h3 class="anchored" data-anchor-id="transform-transformation">Transform transformation</h3>
<p>Some types of transformations are not available for DStreams (e.g., <code>sortBy()</code>, <code>sortByKey()</code>, <code>distinct()</code>), moreover, sometimes it is needed to combine DStreams and RDDs. For example, the functionality of joining every batch in a data stream with another dataset (a standard RDD) is not directly exposed in the DStream API. The <code>transform()</code> transformation can be used in these situations.</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>Transformation</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>transform(func)</code></td>
<td>It is a specific transformation of DStreams that returns a new DStream by applying an RDD-to-RDD function to every RDD of the source Dstream. This can be used to apply arbitrary RDD operations on the DStream</td>
</tr>
</tbody>
</table>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Problem specification</p>
<ul>
<li>Input: a stream of sentences retrieved from localhost:9999</li>
<li>Split the input stream in batches of 5 seconds each and print on the standard output, for each batch, the occurrences of each word appearing in the batch. The pairs must be returned/displayed sorted by decreasing number of occurrences (per batch)</li>
<li>Store the results also in an HDFS folder</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">from</span> pyspark.streaming <span class="im">import</span> StreamingContext</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">## Set prefix of the output folders</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>outputPathPrefix<span class="op">=</span><span class="st">"resSparkStreamingExamples"</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co">#Create a configuration object and#set the name of the applicationconf</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>SparkConf().setAppName(<span class="st">"Streaming word count"</span>)</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">## Create a Spark Context object</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>sc <span class="op">=</span> SparkContext(conf<span class="op">=</span>conf)</span>
<span id="cb8-11"><a href="#cb8-11"></a></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="co">## Create a Spark Streaming Context object</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>ssc <span class="op">=</span> StreamingContext(sc, <span class="dv">5</span>)</span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">## Create a (Receiver) DStream that will connect to localhost:9999</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>lines <span class="op">=</span> ssc.socketTextStream(<span class="st">"localhost"</span>, <span class="dv">9999</span>)</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="co">## Apply a chain of transformations to perform the word count task</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co">## The returned RDDs are DStream RDDs</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>words <span class="op">=</span> lines.flatMap(<span class="kw">lambda</span> line: line.split(<span class="st">" "</span>))</span>
<span id="cb8-21"><a href="#cb8-21"></a>wordsOnes <span class="op">=</span> words.<span class="bu">map</span>(<span class="kw">lambda</span> word: (word, <span class="dv">1</span>))</span>
<span id="cb8-22"><a href="#cb8-22"></a>wordsCounts <span class="op">=</span> wordsOnes.reduceByKey(<span class="kw">lambda</span> v1, v2: v1<span class="op">+</span>v2)</span>
<span id="cb8-23"><a href="#cb8-23"></a></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="co">## Sort the content/the pairs by decreasing value (# of occurrences)</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>wordsCountsSortByKey <span class="op">=</span> wordsCounts <span class="op">\</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>    .transform(<span class="kw">lambda</span> batchRDD: batchRDD.sortBy(<span class="kw">lambda</span> pair: <span class="op">-</span><span class="dv">1</span><span class="op">*</span>pair[<span class="dv">1</span>]))</span>
<span id="cb8-27"><a href="#cb8-27"></a></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="co">## Print the result on the standard output</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>wordsCountsSortByKey.pprint()</span>
<span id="cb8-30"><a href="#cb8-30"></a></span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="co">## Store the result in HDFS</span></span>
<span id="cb8-32"><a href="#cb8-32"></a>wordsCountsSortByKey.saveAsTextFiles(outputPathPrefix, <span class="st">""</span>)</span>
<span id="cb8-33"><a href="#cb8-33"></a></span>
<span id="cb8-34"><a href="#cb8-34"></a><span class="co">#Start the computation</span></span>
<span id="cb8-35"><a href="#cb8-35"></a>ssc.start()</span>
<span id="cb8-36"><a href="#cb8-36"></a></span>
<span id="cb8-37"><a href="#cb8-37"></a><span class="co">## Run this application for 90 seconds</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>ssc.awaitTerminationOrTimeout(<span class="dv">90</span>)</span>
<span id="cb8-39"><a href="#cb8-39"></a>ssc.stop(stopSparkContext<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./20_graph_analytics_2.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Graph Analytics in Spark</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./22_structured_streaming.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>