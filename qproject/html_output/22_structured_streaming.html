<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Distributed architectures for big data processing and analytics - 27&nbsp; Spark structured streaming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./23_streaming_frameworks.html" rel="next">
<link href="./21_streaming_analytics.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Distributed architectures for big data processing and analytics</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Index</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_01_intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Big data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_architectures.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Big data architectures</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03b_HDFS_clc.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">HDFS and Hadoop: command line commands</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_intro_hadoop.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Hadoop and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_hadoop_implementation.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">How to write MapReduce programs in Hadoop</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_mapreduce_patterns_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">MapReduce patterns - 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_mapreduce_advanced_topics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">MapReduce and Hadoop Advanced Topics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_mapreduce_patterns_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">MapReduce patterns - 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_sql_operators_mapreduce.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Relational Algebra Operations and MapReduce</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10b_spark_submit_execute.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">How to submit/execute a Spark application</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_intro_spark.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_rdd_based_programming.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">RDD based programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_rdd_keyvalue_pairs.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">RDDs and key-value pairs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13_rdd_numbers.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">RDD of numbers</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14_cache_accumulators_broadcast.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Cache, Accumulators, Broadcast Variables</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15b_pagerank.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introduction to PageRank</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16_sparksql_dataframes.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Spark SQL and DataFrames</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18a_spark_mllib.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Spark MLlib</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18b_classification.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Classification algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18c_clustering.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Clustering algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18d_regression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Regression algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18e_mining.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Itemset and Association rule mining</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19_graph_analytics_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Graph analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_graph_analytics_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Graph Analytics in Spark</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21_streaming_analytics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22_structured_streaming.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23_streaming_frameworks.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-is-spark-structured-streaming" id="toc-what-is-spark-structured-streaming" class="nav-link active" data-scroll-target="#what-is-spark-structured-streaming">What is Spark structured streaming?</a></li>
  <li><a href="#key-concepts" id="toc-key-concepts" class="nav-link" data-scroll-target="#key-concepts">Key concepts</a></li>
  <li><a href="#event-time-and-window-operations" id="toc-event-time-and-window-operations" class="nav-link" data-scroll-target="#event-time-and-window-operations">Event time and window operations</a></li>
  <li><a href="#join-operations" id="toc-join-operations" class="nav-link" data-scroll-target="#join-operations">Join operations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Spark structured streaming</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="what-is-spark-structured-streaming" class="level3">
<h3 class="anchored" data-anchor-id="what-is-spark-structured-streaming">What is Spark structured streaming?</h3>
<p>Structured Streaming is a scalable and fault-tolerant stream processing engine that is built on the Spark SQL engine, and input data are represented by means of (streaming) DataFrames. Structured Streaming uses the existing Spark SQL APIs to query data streams (the same methods used for analyzing static DataFrames).</p>
<p>A set of specific methods are used to define</p>
<ul>
<li>Input and output streams</li>
<li>Windows</li>
</ul>
<section id="input-data-model" class="level4">
<h4 class="anchored" data-anchor-id="input-data-model">Input data model</h4>
<p>Each input data stream is modeled as a table that is being continuously appended: every time new data arrive they are appended at the end of the table (i.e., each data stream is considered an unbounded input table).</p>
<p>New input data in the stream are new rows appended to an unbounded table</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Input stream</figcaption><p></p>
<p><img src="images/22_structured_streaming/input_data_model.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="queries" class="level4">
<h4 class="anchored" data-anchor-id="queries">Queries</h4>
<p>The expressed queries are incremental queries that are run incrementally on the unbounded input tables.</p>
<ul>
<li>The arrive of new data triggers the execution of the incremental queries</li>
<li>The result of a query at a specific timestamp is the one obtained by running the query on all the data arrived until that timestamp (i.e., stateful queries are executed).</li>
<li>Aggregation queries combine new data with the previous results to optimize the computation of the new results.</li>
</ul>
<p>The queries can be executed</p>
<ul>
<li>As micro-batch queries with a fixed batch interval: this is the standard behavior, with exactly-once fault-tolerance guarantees</li>
<li>As continuous queries: this is experimental behavior, with at-least-once fault-tolerance guarantees</li>
</ul>
<p>In this example the (micro-batch) query is executed every 1 second</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Query execution</figcaption><p></p>
<p><img src="images/22_structured_streaming/query_execution.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Note that every time the query is executed, all data received so far are considered.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li>Input
<ul>
<li>A stream of records retrieved from localhost:9999</li>
<li>Each input record is a reading about the status of a station of a bike sharing system in a specific timestamp #- Each input reading has the format <code>stationId,# free slots,#used slots,timestamp</code></li>
</ul></li>
<li>For each stationId, print on the standard output the total number of received input readings with a number of free slots equal to 0
<ul>
<li>Print the requested information when new data are received by using the micro-batch processing mode</li>
<li>Suppose the batch-duration is set to 2 seconds</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Example execution</figcaption><p></p>
<p><img src="images/22_structured_streaming/stream_example.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</div>
</div>
</div>
</section>
</section>
<section id="key-concepts" class="level3">
<h3 class="anchored" data-anchor-id="key-concepts">Key concepts</h3>
<ul>
<li>Input sources</li>
<li>Transformations</li>
<li>Outputs
<ul>
<li>External destinations/sinks</li>
<li>Output Modes</li>
</ul></li>
<li>Query run/execution</li>
<li>Triggers</li>
</ul>
<section id="input-sources" class="level4">
<h4 class="anchored" data-anchor-id="input-sources">Input sources</h4>
<ul>
<li>File source
<ul>
<li>Reads files written in a directory as a stream of data</li>
<li>Each line of the input file is an input record</li>
<li>Supported file formats are text, csv, json, orc, parquet, …</li>
</ul></li>
<li>Kafka source
<ul>
<li>Reads data from Kafka</li>
<li>Each Kafka message is one input record</li>
</ul></li>
<li>Socket source (for debugging purposes)
<ul>
<li>Reads UTF8 text data from a socket connection</li>
<li>This type of source does not provide end-to-end fault-tolerance guarantees</li>
</ul></li>
<li>Rate source (for debugging purposes)
<ul>
<li>Generates data at the specified number of rows per second</li>
<li>Each generated row contains a timestamp and value of type long</li>
</ul></li>
</ul>
<p>The <code>readStream</code> property of the <code>SparkSession</code> class is used to create <code>DataStreamReaders</code>: the methods <code>format()</code> and <code>option()</code> of the <code>DataStreamReader</code> class are used to specify the input streams (e.g., type, location). The method <code>load()</code> of the <code>DataStreamReader</code> class is used to return DataFrames associated with the input data streams.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In this example the (streaming) DataFrame recordsDF is created and associated with the input stream of type socket</p>
<ul>
<li>Address: localhost</li>
<li>Input port: 9999</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>recordsDF <span class="op">=</span> spark.readStream <span class="op">\</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    .<span class="bu">format</span>(<span class="st">"socket"</span>) <span class="op">\</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    .option(<span class="st">"host"</span>, <span class="st">"localhost"</span>) <span class="op">\</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    .option(<span class="st">"port"</span>, <span class="dv">9999</span>) <span class="op">\</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    .load() <span class="co"># &lt;1&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>Test</li>
</ol>
</div>
</div>
</div>
</section>
<section id="transformations" class="level4">
<h4 class="anchored" data-anchor-id="transformations">Transformations</h4>
<p>Transformations are the same of DataFrames, however there are restrictions on some types of queries/transformations that cannot be executed incrementally.</p>
<p>Unsupported operations:</p>
<ul>
<li>Multiple streaming aggregations (i.e.&nbsp;a chain of aggregations on a streaming DataFrame)</li>
<li>Limit and take first N rows</li>
<li>Distinct operations</li>
<li>Sorting operations are supported on streaming DataFrames only after an aggregation and in complete output mode</li>
<li>Few types of outer joins on streaming DataFrames are not supported</li>
</ul>
</section>
<section id="outputs" class="level4">
<h4 class="anchored" data-anchor-id="outputs">Outputs</h4>
<ul>
<li>Sinks: they are instances of the class DataStreamWriter and are used to specify the external destinations and store the results in the external destinations</li>
<li>File sink: it stores the output to a directory; supported file formats are text, csv, json, orc, parquet, …</li>
<li>Kafka sink: it stores the output to one or more topics in Kafka</li>
<li>Foreach sink: it runs arbitrary computation on the output records</li>
<li>Console sink (for debugging purposes): it prints the computed output to the console every time a new batch of records has been analyzed; this should be used for debugging purposes on low data volumes as the entire output is collected and stored in the driver’s memory after each computation</li>
<li>Memory sink (for debugging purposes): the output is stored in memory as an in-memory table; this should be used for debugging purposes on low data volumes as the entire output is collected and stored in the driver’s memory</li>
</ul>
<section id="output-mods" class="level5">
<h5 class="anchored" data-anchor-id="output-mods">Output mods</h5>
<p>We must define how we want Spark to write output data in the external destinations. The supported output modes depend on the query type, and the possible output mods are the following</p>
<section id="append" class="level6">
<h6 class="anchored" data-anchor-id="append">Append</h6>
<p>This is the default mode. Only the new rows added to the computed result since the last trigger (computation) will be outputted. This mode is supported for only those queries where rows added to the result is never going to change: this mode guarantees that each row will be output only once. So, the supported queries are only select, filter, map, flatMap, filter, join, etc.</p>
</section>
<section id="complete" class="level6">
<h6 class="anchored" data-anchor-id="complete">Complete</h6>
<p>The whole computed result will be outputted to the sink after every trigger (computation). This mode is supported for aggregation queries.</p>
</section>
<section id="update" class="level6">
<h6 class="anchored" data-anchor-id="update">Update</h6>
<p>Only the rows in the computed result that were updated since the last trigger (computation) will be outputted.</p>
<p>The complete list of supported output modes for each query type is available in the <a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html">Apache Spark documentation</a>.</p>
</section>
</section>
<section id="code" class="level5">
<h5 class="anchored" data-anchor-id="code">Code</h5>
<p>The <code>writeStream</code> property of the <code>SparkSession</code> class is used to create <code>DataStreamWriters</code>. The methods <code>outputMode()</code>, <code>format()</code>, and <code>option()</code> of the <code>DataStreamWriter</code> class are used to specify the output destination (data format, location, output mode, etc.).</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Example The <code>DataStreamWriter</code> “streamWriterRes” is created and associated with the console. The output mode is set to append.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>streamWriterRes <span class="op">=</span> stationIdTimestampDF <span class="op">\</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    .writeStream <span class="op">\</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    .outputMode(<span class="st">"append"</span>) <span class="op">\</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    .<span class="bu">format</span>(<span class="st">"console"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="query-runexecution" class="level4">
<h4 class="anchored" data-anchor-id="query-runexecution">Query run/execution</h4>
<p>To start executing the defined queries/structured streaming applications you must explicitly invoke the <code>start()</code> action on the defined sinks (<code>DataStreamWriter</code> objects associated with the external destinations in which the results will be stored). It is possible to start several queries in the same application, and structured streaming queries run forever (they must be explicitly stop/kill).</p>
</section>
<section id="triggers" class="level4">
<h4 class="anchored" data-anchor-id="triggers">Triggers</h4>
<p>For each Spark structured streaming query it is possible to specify when new input data must be processed, and whether the query is going to be executed as a micro-batch query with a fixed batch interval or as a continuous processing query (experimental). The trigger type for each query is specified by means of the <code>trigger()</code> method of the <code>DataStreamWriter</code> class.</p>
<section id="trigger-types" class="level5">
<h5 class="anchored" data-anchor-id="trigger-types">Trigger types</h5>
<p>No trigger type is explicitly specified, by default the query will be executed in micro-batch mode, where each micro-batch is generated and processed as soon as the previous micro-batch has been processed.</p>
<section id="fixed-interval-micro-batches" class="level6">
<h6 class="anchored" data-anchor-id="fixed-interval-micro-batches">Fixed interval micro-batches</h6>
<p>The query will be executed in micro-batch mode. Micro-batches will be processed at the user-specified intervals: the parameter <code>processingTime</code> of the trigger <code>method()</code> is used to specify the micro-batch size, and, if the previous micro-batch completes within its interval, then the engine will wait until the interval is over before processing the next micro-batch; if the previous micro-batch takes longer than the interval to complete (i.e.&nbsp;if an interval boundary is missed), then the next micro-batch will start as soon as the previous one completes.</p>
</section>
<section id="one-time-micro-batch" class="level6">
<h6 class="anchored" data-anchor-id="one-time-micro-batch">One-time micro-batch</h6>
<p>The query will be executed in micro-batch mode, but the query will be executed only one time on one single micro-batch containing all the available data of the input stream; after the single execution the query stops on its own. This trigger type is useful when the goal is to periodically spin up a cluster, process everything that is available since the last period, and then shutdown the cluster. In some case, this may lead to significant cost savings.</p>
</section>
<section id="continuous-with-fixed-checkpoint-interval-experimental" class="level6">
<h6 class="anchored" data-anchor-id="continuous-with-fixed-checkpoint-interval-experimental">Continuous with fixed checkpoint interval (experimental)</h6>
<p>The query will be executed in the new low-latency, continuous processing mode. It offers at-least-once fault-tolerance guarantees.</p>
</section>
</section>
</section>
<section id="spark-structured-streaming-examples" class="level4">
<h4 class="anchored" data-anchor-id="spark-structured-streaming-examples">Spark structured streaming examples</h4>
<section id="example-1" class="level5">
<h5 class="anchored" data-anchor-id="example-1">Example 1</h5>
<ul>
<li>Input
<ul>
<li>A stream of records retrieved from localhost:9999</li>
<li>Each input record is a reading about the status of a station of a bike sharing system in a specific timestamp #- Each input reading has the format: “stationId”, “# free slots”, “#used slots”, “timestamp”</li>
</ul></li>
<li>Output
<ul>
<li>For each input reading with a number of free slots equal to 0 print on the standard output the value of stationId and timestamp</li>
<li>Use the standard micro-batch processing mode</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">from</span> pyspark.sql.types <span class="im">import</span> <span class="op">*</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> split</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">## Create a "receiver" DataFrame that will connect to localhost:9999</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>recordsDF <span class="op">=</span> spark.readStream <span class="op">\</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    .<span class="bu">format</span>(<span class="st">"socket"</span>) <span class="op">\</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    .option(<span class="st">"host"</span>, <span class="st">"localhost"</span>) <span class="op">\</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    .option(<span class="st">"port"</span>, <span class="dv">9999</span>) <span class="op">\</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    .load()</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">## The input records are characterized by one single column called value</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">## of type string</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">## Example of an input record: s1,0,3,2016-03-11 09:00:04</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">## Define four more columns by splitting the input column value</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">## New columns:</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">## - stationId</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">## - freeslots</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">## - usedslots</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">## - timestamp</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>readingsDF <span class="op">=</span> recordsDF <span class="op">\</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>    .withColumn(<span class="st">"stationId"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">0</span>].cast(<span class="st">"string"</span>)) \ </span>
<span id="cb3-22"><a href="#cb3-22"></a>    .withColumn(<span class="st">"freeslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">1</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>    .withColumn(<span class="st">"usedslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">2</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="co">#.withColumn("timestamp", split(recordsDF.value, ',')[3].cast("timestamp")) # &lt;1&gt;</span></span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a><span class="co">## Filter data</span></span>
<span id="cb3-27"><a href="#cb3-27"></a><span class="co">## Use the standard filter transformation</span></span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="co">#fullReadingsDF = readingsDF.filter("freeslots=0") # &lt;2&gt;</span></span>
<span id="cb3-29"><a href="#cb3-29"></a></span>
<span id="cb3-30"><a href="#cb3-30"></a><span class="co">## Select stationid and timestamp</span></span>
<span id="cb3-31"><a href="#cb3-31"></a><span class="co">## Use the standard select transformation</span></span>
<span id="cb3-32"><a href="#cb3-32"></a><span class="co">#stationIdTimestampDF = fullReadingsDF.select("stationId", "timestamp") # &lt;2&gt;</span></span>
<span id="cb3-33"><a href="#cb3-33"></a></span>
<span id="cb3-34"><a href="#cb3-34"></a><span class="co">## The result of the structured streaming query will be stored/printed on</span></span>
<span id="cb3-35"><a href="#cb3-35"></a><span class="co">## the console "sink“.</span></span>
<span id="cb3-36"><a href="#cb3-36"></a><span class="co">## append output mode</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>queryFilterStreamWriter <span class="op">=</span> stationIdTimestampDF <span class="op">\</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>    .writeStream <span class="op">\</span></span>
<span id="cb3-39"><a href="#cb3-39"></a>    .outputMode(<span class="st">"append"</span>) <span class="op">\</span></span>
<span id="cb3-40"><a href="#cb3-40"></a>    .<span class="bu">format</span>(<span class="st">"console"</span>)</span>
<span id="cb3-41"><a href="#cb3-41"></a></span>
<span id="cb3-42"><a href="#cb3-42"></a><span class="co">## Start the execution of the query (it will be executed until it is explicitly stopped)</span></span>
<span id="cb3-43"><a href="#cb3-43"></a>queryFilter <span class="op">=</span> queryFilterStreamWriter.start()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>withColumn()</code> is used to add new columns (it is a standard DataFrame method). It returns a DataFrame with the same columns of the input DataFrame and the new defined column. For each new column it is possible to specify name (e.g.&nbsp;“stationId”) and the SQL function that is used to define its value in each record. The <code>cast()</code> method is used to specify the data type of each defined column.</li>
<li><code>filter</code> and <code>select</code> are standard DataFrame transformations</li>
</ol>
</section>
<section id="example-2" class="level5">
<h5 class="anchored" data-anchor-id="example-2">Example 2</h5>
<ul>
<li>Input
<ul>
<li>A stream of records retrieved from localhost:9999</li>
<li>Each input record is a reading about the status of a station of</li>
<li>bike sharing system in a specific timestamp #- Each input reading has the format: “stationId”, “# free slots”, “#used slots”, “timestamp”</li>
</ul></li>
<li>Output
<ul>
<li>For each stationId, print on the standard output the total number of received input readings with a number of free slots equal to 0</li>
<li>Print the requested information when new data are received by using the standard micro-batch processing mode</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> pyspark.sql.types <span class="im">import</span> <span class="op">*</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> split</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">## Create a "receiver" DataFrame that will connect to localhost:9999</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>recordsDF <span class="op">=</span> spark.readStream <span class="op">\</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    .<span class="bu">format</span>(<span class="st">"socket"</span>) <span class="op">\</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    .option(<span class="st">"host"</span>, <span class="st">"localhost"</span>) <span class="op">\</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    .option(<span class="st">"port"</span>, <span class="dv">9999</span>) <span class="op">\</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    .load()</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">## The input records are characterized by one single column called value</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">## of type string</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">## Example of an input record: s1,0,3,2016-03-11 09:00:04</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">## Define four more columns by splitting the input column value</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">## New columns:</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">## - stationId</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="co">## - freeslots</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co">## - usedslots</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="co">## - timestamp</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>readingsDF <span class="op">=</span> recordsDF <span class="op">\</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>    .withColumn(<span class="st">"stationId"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">0</span>].cast(<span class="st">"string"</span>)) <span class="op">\</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>    .withColumn(<span class="st">"freeslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">1</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>    .withColumn(<span class="st">"usedslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">2</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>    .withColumn(<span class="st">"timestamp"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">3</span>].cast(<span class="st">"timestamp"</span>))</span>
<span id="cb4-25"><a href="#cb4-25"></a></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="co">## Filter data</span></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="co">## Use the standard filter transformation</span></span>
<span id="cb4-28"><a href="#cb4-28"></a>fullReadingsDF <span class="op">=</span> readingsDF.<span class="bu">filter</span>(<span class="st">"freeslots=0"</span>)</span>
<span id="cb4-29"><a href="#cb4-29"></a></span>
<span id="cb4-30"><a href="#cb4-30"></a><span class="co">## Count the number of readings with a number of free slots equal to 0</span></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="co">## for each stationId</span></span>
<span id="cb4-32"><a href="#cb4-32"></a><span class="co">## The standard groupBy method is used</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>countsDF <span class="op">=</span> fullReadingsDF <span class="op">\</span></span>
<span id="cb4-34"><a href="#cb4-34"></a>    .groupBy(<span class="st">"stationId"</span>) <span class="op">\</span></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="co">#.agg({"*":"count"}) # &lt;1&gt;</span></span>
<span id="cb4-36"><a href="#cb4-36"></a></span>
<span id="cb4-37"><a href="#cb4-37"></a><span class="co">## The result of the structured streaming query will be stored/printed on</span></span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="co">## the console "sink"</span></span>
<span id="cb4-39"><a href="#cb4-39"></a><span class="co">## complete output mode</span></span>
<span id="cb4-40"><a href="#cb4-40"></a><span class="co">## (append mode cannot be used for aggregation queries)</span></span>
<span id="cb4-41"><a href="#cb4-41"></a>queryCountStreamWriter <span class="op">=</span> countsDF <span class="op">\</span></span>
<span id="cb4-42"><a href="#cb4-42"></a>    .writeStream <span class="op">\</span></span>
<span id="cb4-43"><a href="#cb4-43"></a>    .outputMode(<span class="st">"complete"</span>) <span class="op">\</span></span>
<span id="cb4-44"><a href="#cb4-44"></a>    .<span class="bu">format</span>(<span class="st">"console"</span>)</span>
<span id="cb4-45"><a href="#cb4-45"></a></span>
<span id="cb4-46"><a href="#cb4-46"></a><span class="co">## Start the execution of the query (it will be executed until it is explicitly stopped)</span></span>
<span id="cb4-47"><a href="#cb4-47"></a>queryCount <span class="op">=</span> queryCountStreamWriter.start()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>groupBy</code> and <code>agg</code> are standard DataFrame transformations</li>
</ol>
</section>
</section>
</section>
<section id="event-time-and-window-operations" class="level3">
<h3 class="anchored" data-anchor-id="event-time-and-window-operations">Event time and window operations</h3>
<p>Input streaming records are usually characterized by a time information: it is usually called event-time, and it is the time when the data was generated. For many applications, you want to operate by taking into consideration the event-time and windows containing data associated with the same event-time range.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Compute the number of events generated by each monitored IoT device every minute based on the event-time. For each window associated with one distinct minute, consider only the data with an event-time inside that minute/window and compute the number of events for each IoT device: one computation for each minute/window. You want to use the time when the data was generated (i.e., the event-time) rather than the time Spark receives them.</p>
</div>
</div>
</div>
<p>Spark allows defining windows based on the time-event input column, and then apply aggregation functions over each window.</p>
<p>For each structured streaming query on which you want to apply a window computation you must specify</p>
<ul>
<li>the name of the time-event column in the input (streaming) DataFrame</li>
<li>the characteristics of the (sliding) windows
<ul>
<li><code>windowDuration</code></li>
<li><code>slideDuration</code></li>
</ul></li>
</ul>
<p>Do not set it if you want non-overlapped windows, (i.e., if you want to a <code>slideDuration</code> equal to <code>windowDuration</code>). You can set different window characteristics for each query of your application.</p>
<p>The <code>window(timeColumn, windowDuration, slideDuration=None)</code> function is used inside the standard <code>groupBy()</code> one to specify the characteristics of the windows. Notice that windows can be used only with queries that are applying aggregation functions.</p>
<section id="event-time-and-window-operations-example-1" class="level4">
<h4 class="anchored" data-anchor-id="event-time-and-window-operations-example-1">Event time and window operations: example 1</h4>
<ul>
<li>Input
<ul>
<li>A stream of records retrieved from localhost:9999</li>
<li>Each input record is a reading about the status of a station of a bike sharing system in a specific timestamp #- Each input reading has the format: “stationId”, “# free slots”, “#used slots”, “timestamp”</li>
<li>timestamp is the event-time column</li>
</ul></li>
<li>Output
<ul>
<li>For each stationId, print on the standard output the total number of received input readings with a number of free slots equal to 0 in each window</li>
<li>The query is executed for each window</li>
<li>Set <code>windowDuration</code> to 2 seconds and no <code>slideDuration</code> (i.e., non-overlapped windows)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 1</figcaption><p></p>
<p><img src="images/22_structured_streaming/example_3_1.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>The returned result has a column called window. It contains the time slot associated with the window <span class="math inline">\([\text{from timestamp}, \text{to timestamp})\)</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 2</figcaption><p></p>
<p><img src="images/22_structured_streaming/example_3_2.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 3</figcaption><p></p>
<p><img src="images/22_structured_streaming/example_3_3.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> pyspark.sql.types <span class="im">import</span> <span class="op">*</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> split</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> window</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">## Create a "receiver" DataFrame that will connect to localhost:9999</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>recordsDF <span class="op">=</span> spark.readStream <span class="op">\</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    .<span class="bu">format</span>(<span class="st">"socket"</span>) <span class="op">\</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    .option(<span class="st">"host"</span>, <span class="st">"localhost"</span>) <span class="op">\</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    .option(<span class="st">"port"</span>, <span class="dv">9999</span>) <span class="op">\</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    .load()</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">## The input records are characterized by one single column called value</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">## of type string</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co">## Example of an input record: s1,0,3,2016-03-11 09:00:04</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">## Define four more columns by splitting the input column value</span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="co">## New columns:</span></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">## - stationId</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">## - freeslots</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="co">## - usedslots</span></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="co">## - timestamp</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>readingsDF <span class="op">=</span> recordsDF <span class="op">\</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>    .withColumn(<span class="st">"stationId"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">0</span>].cast(<span class="st">"string"</span>)) <span class="op">\</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>    .withColumn(<span class="st">"freeslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">1</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb5-24"><a href="#cb5-24"></a>    .withColumn(<span class="st">"usedslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">2</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>    .withColumn(<span class="st">"timestamp"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">3</span>].cast(<span class="st">"timestamp"</span>))</span>
<span id="cb5-26"><a href="#cb5-26"></a></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co">## Filter data</span></span>
<span id="cb5-28"><a href="#cb5-28"></a><span class="co">## Use the standard filter transformation</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>fullReadingsDF <span class="op">=</span> readingsDF.<span class="bu">filter</span>(<span class="st">"freeslots=0"</span>)</span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="co">## Count the number of readings with a number of free slots equal to 0</span></span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="co">## for each stationId in each window.</span></span>
<span id="cb5-33"><a href="#cb5-33"></a><span class="co">## windowDuration = 2 seconds</span></span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="co">## no overlapping windows</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>countsDF <span class="op">=</span> fullReadingsDF <span class="op">\</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>    .groupBy(window(fullReadingsDF.timestamp, <span class="st">"2 seconds"</span>), <span class="st">"stationId"</span>) <span class="op">\</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>    .agg({<span class="st">"*"</span>:<span class="st">"count"</span>}) <span class="op">\</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>    .sort(<span class="st">"window"</span>)</span>
<span id="cb5-39"><a href="#cb5-39"></a></span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="co">## The result of the structured streaming query will be stored/printed on</span></span>
<span id="cb5-41"><a href="#cb5-41"></a><span class="co">## the console "sink"</span></span>
<span id="cb5-42"><a href="#cb5-42"></a><span class="co">## complete output mode</span></span>
<span id="cb5-43"><a href="#cb5-43"></a><span class="co">## (append mode cannot be used for aggregation queries)</span></span>
<span id="cb5-44"><a href="#cb5-44"></a>queryCountWindowStreamWriter <span class="op">=</span> countsDF <span class="op">\</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>    .writeStream <span class="op">\</span></span>
<span id="cb5-46"><a href="#cb5-46"></a>    .outputMode(<span class="st">"complete"</span>) <span class="op">\</span></span>
<span id="cb5-47"><a href="#cb5-47"></a>    .<span class="bu">format</span>(<span class="st">"console"</span>) <span class="op">\</span></span>
<span id="cb5-48"><a href="#cb5-48"></a>    .option(<span class="st">"truncate"</span>, <span class="st">"false"</span>)</span>
<span id="cb5-49"><a href="#cb5-49"></a></span>
<span id="cb5-50"><a href="#cb5-50"></a><span class="co">## Start the execution of the query (it will be executed until it is explicitly stopped)</span></span>
<span id="cb5-51"><a href="#cb5-51"></a>queryCountWindow <span class="op">=</span> queryCountWindowStreamWriter.start()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="late-data" class="level4">
<h4 class="anchored" data-anchor-id="late-data">Late data</h4>
<p>Sparks handles data that have arrived later than expected based on its event-time; these are called late data. Spark has full control over updating old aggregates when there are late data: every time new data are processed the result is computed by combining old aggregate values and the new data by considering the event-time column instead of the time Spark receives the data.</p>
<section id="late-data-example" class="level5">
<h5 class="anchored" data-anchor-id="late-data-example">Late data example</h5>
<ul>
<li>Input
<ul>
<li>A stream of records retrieved from localhost:9999</li>
<li>Each input record is a reading about the status of a station of a bike sharing system in a specific timestamp #- Each input reading has the format: “stationId”, “# free slots”, “#used slots”, “timestamp”</li>
<li>timestamp is the event-time column</li>
</ul></li>
<li>Output
<ul>
<li>For each stationId, print on the standard output the total number of received input readings with a number of free slots equal to 0 in each window</li>
<li>The query is executed for each window</li>
<li>Set <code>windowDuration</code> to 2 seconds and no <code>slideDuration</code> (i.e., non-overlapped windows)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 1</figcaption><p></p>
<p><img src="images/22_structured_streaming/late_data_example_1.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 2</figcaption><p></p>
<p><img src="images/22_structured_streaming/late_data_example_2.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 3</figcaption><p></p>
<p><img src="images/22_structured_streaming/late_data_example_3.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Notice that late data that was generated at <strong><em>2016-03-11 09:00:06</em></strong>, but arrived at <strong><em>2016-03-11 09:00:08</em></strong>: the result consider also late data and assign them to the right window by considering the event-time information.</p>
<p>The code is the same of the previous example (Event time and window operations: example 1): late data are automatically handled by Spark.</p>
</section>
</section>
<section id="event-time-and-window-operations-example-2" class="level4">
<h4 class="anchored" data-anchor-id="event-time-and-window-operations-example-2">Event time and window operations: example 2</h4>
<ul>
<li>Input
<ul>
<li>A stream of records retrieved from localhost:9999</li>
<li>Each input record is a reading about the status of a station of a bike sharing system in a specific timestamp #- Each input reading has the format: “stationId”, “# free slots”, “#used slots”, “timestamp”</li>
<li>timestamp is the event-time column</li>
</ul></li>
<li>Output
<ul>
<li>For each window, print on the standard output the total number of received input readings with a number of free slots equal to 0</li>
<li>The query is executed for each window</li>
<li>Set windowDuration to 2 seconds and no slideDuration (i.e., non-overlapped windows)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 1</figcaption><p></p>
<p><img src="images/22_structured_streaming/example_4_1.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 2</figcaption><p></p>
<p><img src="images/22_structured_streaming/example_4_2.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p></p><figcaption class="figure-caption">Step 3</figcaption><p></p>
<p><img src="images/22_structured_streaming/example_4_3.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> pyspark.sql.types <span class="im">import</span> <span class="op">*</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> split</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> window</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">## Create a "receiver" DataFrame that will connect to localhost:9999</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>recordsDF <span class="op">=</span> spark.readStream <span class="op">\</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    .<span class="bu">format</span>(<span class="st">"socket"</span>) <span class="op">\</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    .option(<span class="st">"host"</span>, <span class="st">"localhost"</span>) <span class="op">\</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    .option(<span class="st">"port"</span>, <span class="dv">9999</span>) <span class="op">\</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    .load()</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">## The input records are characterized by one single column called value</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">## of type string</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">## Example of an input record: s1,0,3,2016-03-11 09:00:04</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">## Define four more columns by splitting the input column value</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">## New columns:</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="co">## - stationId</span></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">## - freeslots</span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co">## - usedslots</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co">## - timestamp</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>readingsDF <span class="op">=</span> recordsDF <span class="op">\</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>    .withColumn(<span class="st">"stationId"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">0</span>].cast(<span class="st">"string"</span>)) <span class="op">\</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>    .withColumn(<span class="st">"freeslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">1</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>    .withColumn(<span class="st">"usedslots"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">2</span>].cast(<span class="st">"integer"</span>)) <span class="op">\</span></span>
<span id="cb6-25"><a href="#cb6-25"></a>    .withColumn(<span class="st">"timestamp"</span>, split(recordsDF.value, <span class="st">','</span>)[<span class="dv">3</span>].cast(<span class="st">"timestamp"</span>))</span>
<span id="cb6-26"><a href="#cb6-26"></a></span>
<span id="cb6-27"><a href="#cb6-27"></a><span class="co">## Filter data</span></span>
<span id="cb6-28"><a href="#cb6-28"></a><span class="co">## Use the standard filter transformation</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>fullReadingsDF <span class="op">=</span> readingsDF.<span class="bu">filter</span>(<span class="st">"freeslots=0"</span>)</span>
<span id="cb6-30"><a href="#cb6-30"></a></span>
<span id="cb6-31"><a href="#cb6-31"></a><span class="co">## Count the number of readings with a number of free slots equal to 0</span></span>
<span id="cb6-32"><a href="#cb6-32"></a><span class="co">## for in each window.</span></span>
<span id="cb6-33"><a href="#cb6-33"></a><span class="co">## windowDuration = 2 seconds</span></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="co">## no overlapping windows</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>countsDF <span class="op">=</span> fullReadingsDF <span class="op">\</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>    .groupBy(window(fullReadingsDF.timestamp, <span class="st">"2 seconds"</span>)) <span class="op">\</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>    .agg({<span class="st">"*"</span>:<span class="st">"count"</span>}) <span class="op">\</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>    .sort(<span class="st">"window"</span>)</span>
<span id="cb6-39"><a href="#cb6-39"></a></span>
<span id="cb6-40"><a href="#cb6-40"></a><span class="co">## The result of the structured streaming query will be stored/printed on</span></span>
<span id="cb6-41"><a href="#cb6-41"></a><span class="co">## the console "sink"</span></span>
<span id="cb6-42"><a href="#cb6-42"></a><span class="co">## complete output mode</span></span>
<span id="cb6-43"><a href="#cb6-43"></a><span class="co">## (append mode cannot be used for aggregation queries)</span></span>
<span id="cb6-44"><a href="#cb6-44"></a>queryCountWindowStreamWriter <span class="op">=</span> countsDF <span class="op">\</span></span>
<span id="cb6-45"><a href="#cb6-45"></a>    .writeStream <span class="op">\</span></span>
<span id="cb6-46"><a href="#cb6-46"></a>    .outputMode(<span class="st">"complete"</span>) <span class="op">\</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>    .<span class="bu">format</span>(<span class="st">"console"</span>) <span class="op">\</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>    .option(<span class="st">"truncate"</span>, <span class="st">"false"</span>)</span>
<span id="cb6-49"><a href="#cb6-49"></a></span>
<span id="cb6-50"><a href="#cb6-50"></a><span class="co">## Start the execution of the query (it will be executed until it is </span></span>
<span id="cb6-51"><a href="#cb6-51"></a><span class="co">## explicitly stopped)</span></span>
<span id="cb6-52"><a href="#cb6-52"></a>queryCountWindow <span class="op">=</span> queryCountWindowStreamWriter.start()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="watermarking" class="level4">
<h4 class="anchored" data-anchor-id="watermarking">Watermarking</h4>
<p>Watermarking is a feature of Spark that allows the user to specify the threshold of late data, and allows the engine to accordingly clean up old state. Results related to old event-times are not needed in many real streaming applications: they can be dropped to improve the efficiency of the application, since keeping the state of old results is resource expensive; in this way every time new data are processed only recent records are considered.</p>
<p>Specifically, to run windowed queries for days, it is necessary for the system to bound the amount of intermediate in-memory state it accumulates. This means the system needs to know when an old aggregate can be dropped from the in-memory state because the application is not going to receive late data for that aggregate any more; to enable this, in Spark 2.1, watermarking has been introduced.</p>
<p>Watermarking lets the Spark Structured Streaming engine automatically track the current event time in the data and attempt to clean up old state accordingly. It allows to define the watermark of a query by specifying the event time column and the threshold on how late the data is expected to be in terms of event time: for a specific window ending at time <span class="math inline">\(T\)</span>, the engine will maintain state and allow late data to update the state/the result until max event time seen by the engine <span class="math inline">\(&lt; T + \text{late threshold}\)</span>. In other words, late data within the threshold will be aggregated, but data later than <span class="math inline">\({T + \text{threshold}}\)</span> will be dropped.</p>
</section>
</section>
<section id="join-operations" class="level3">
<h3 class="anchored" data-anchor-id="join-operations">Join operations</h3>
<p>Spark Structured Streaming manages also join operations</p>
<ul>
<li>Between two streaming DataFrames</li>
<li>Between a streaming DataFrame and a static DataFrame</li>
</ul>
<p>The result of the streaming join is generated incrementally.</p>
<p>When joining between two streaming DataFrames, for both input streams, past input streaming data must be buffered/recorded in order to be able to match every future input record with past input data and accordingly generate joined results. Too many resources are needed for storing all the input data, hence, old data must be discarded. Watermark thresholds must be defined on both input streams such that the engine knows how delayed the input can be and drop old data.</p>
<p>The methods <code>join()</code> and <code>withWatermark()</code> are used to join streaming DataFrames: the join method is similar to the one available for static DataFrame.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> expr</span>
<span id="cb7-2"><a href="#cb7-2"></a>impressions <span class="op">=</span> spark.readStream. ...</span>
<span id="cb7-3"><a href="#cb7-3"></a>clicks <span class="op">=</span> spark.readStream. ...</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">## Apply watermarks on event-time columns</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>impressionsWithWatermark <span class="op">=</span> impressions <span class="op">\</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    .withWatermark(<span class="st">"impressionTime"</span>, <span class="st">"2 hours"</span>)</span>
<span id="cb7-8"><a href="#cb7-8"></a>    </span>
<span id="cb7-9"><a href="#cb7-9"></a>clicksWithWatermark <span class="op">=</span> clicks <span class="op">\</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    .withWatermark(<span class="st">"clickTime"</span>, <span class="st">"3 hours"</span>)</span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">## Join with event-time constraints</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>impressionsWithWatermark.join(</span>
<span id="cb7-14"><a href="#cb7-14"></a>    clicksWithWatermark,</span>
<span id="cb7-15"><a href="#cb7-15"></a>    expr(</span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="st">"""</span></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="st">        clickAdId = impressionAdId AND </span></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="st">        clickTime &gt;= impressionTime AND</span></span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="st">        clickTime &lt;= impressionTime + interval 1 hour"""</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>    ) </span>
<span id="cb7-21"><a href="#cb7-21"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./21_streaming_analytics.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./23_streaming_frameworks.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Streaming data analytics frameworks</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>